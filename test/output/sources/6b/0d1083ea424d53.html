<!DOCTYPE html><html lang='en'><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>test output - test.html</title><link href="../../static/bootstrap/css/bootstrap.min.css" rel="stylesheet"><link href="../../static/bootstrap/css/dropdowns-enhancement.min.css" rel="stylesheet"><link href="../../static/animated-modal/animate.min.css" rel="stylesheet"><link href="../../static/font-awesome/css/font-awesome.min.css" rel="stylesheet"><link href="../../static/style.css" rel="stylesheet"></head><body><div class="container-fluid"><div class="container"><nav class="navbar navbar-default navbar-fixed-top"><div class="container-fluid" id="navbar"><!-- Brand and toggle get grouped for better mobile display --><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><span class="navbar-brand" style="padding-top: 8px"><ol id="path" itemscope itemtype="http://schema.org/BreadcrumbList"><!-- ROOT DIRECTORY --><li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem"><a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="../be/e2916b98dcf1fc.html"><i itemprop="image" alt="root" class="glyphicon glyphicon-hdd" style="vertical-align: middle"></i>&nbsp;</a></li></ol>test.html</span></div><!-- Collect the nav links, forms, and other content for toggling --><!-- mostly taken from http://www.bootply.com/t7O3HSGlbc --><div class="collapse navbar-collapse" id="main-navbar"><div class="form-group" style="margin-top: 8px; margin-bottom: 0px;"><div class="input-group"><div class="input-group-btn"><button class="btn btn-default correct-height" data-label-placement><i class="glyphicon glyphicon-console data-label"></i></button><button data-toggle="dropdown" class="btn btn-default dropdown-toggle correct-height"><span class="caret"></span> </button><ul class="dropdown-menu"><li><input type="radio" id="sb-symbol" name="sb" value="symbol" checked><label for="sb-symbol"><i class="glyphicon glyphicon-console data-label"></i> Symbol</label></li><li><input type="radio" id="sb-file" name="sb" value="file"><label for="sb-file"><i class="glyphicon glyphicon-file data-label"></i> File</label></li><li><input type="radio" id="sb-text" name="sb" value="text"><label for="sb-text"><i class="glyphicon glyphicon-text-background data-label"></i> Text</label></li><li><input type="radio" id="sb-line" name="sb" value="line"><label for="sb-line"><i class="glyphicon glyphicon-indent-left data-label"></i> Line</label></li></ul></div><input type="text" name="search" id="searchbox-symbol" class="form-control" placeholder="Search symbol (std::list, list, kfree_skb, any full or partial variable/class/function/... name)"><input type="text" name="search" id="searchbox-file" class="form-control hidden" placeholder="Search file (/usr/include/alloca.h, alloca.h, any full or partial path)"><input type="text" name="search" id="searchbox-text" class="form-control hidden" placeholder="Search text (content of comments, strings, full text search over the source code)"><input type="text" name="search" id="searchbox-line" class="form-control hidden" placeholder="Go to line (53, 1120, just type the line number and enter)"><div class="input-group-btn"><div class="btn-group hidden" id="tag-menu"><button data-toggle="dropdown" class="btn btn-default dropdown-toggle" id="tag-default"></button><ul class="dropdown-menu pull-center" id="tag-entries"></ul></div><a class="btn btn-default" href="../meta/about.html" type="button" id="sbexr-about"><i title="About this site" class="glyphicon glyphicon-info-sign"></i></a><a class="btn btn-default" href="../meta/help.html" type="button" id="sbexr-help"><i title="Help!!" class="glyphicon glyphicon-question-sign"></i></a></div></div></div></div><!-- /.navbar-collapse --></div><!-- /.container-fluid --></nav></div><pre class='code'><span id='line-number'><i>1</i><i>2</i><i>3</i><i>4</i><i>5</i><i>6</i><i>7</i><i>8</i><i>9</i><i>10</i><i>11</i><i>12</i><i>13</i><i>14</i><i>15</i><i>16</i><i>17</i><i>18</i><i>19</i><i>20</i><i>21</i><i>22</i><i>23</i><i>24</i><i>25</i><i>26</i><i>27</i><i>28</i><i>29</i><i>30</i><i>31</i><i>32</i><i>33</i><i>34</i><i>35</i><i>36</i><i>37</i><i>38</i><i>39</i><i>40</i><i>41</i><i>42</i><i>43</i><i>44</i><i>45</i><i>46</i><i>47</i><i>48</i><i>49</i><i>50</i><i>51</i><i>52</i><i>53</i><i>54</i><i>55</i><i>56</i><i>57</i><i>58</i><i>59</i><i>60</i><i>61</i><i>62</i><i>63</i><i>64</i><i>65</i><i>66</i><i>67</i><i>68</i><i>69</i><i>70</i><i>71</i><i>72</i><i>73</i><i>74</i><i>75</i><i>76</i><i>77</i><i>78</i><i>79</i><i>80</i><i>81</i><i>82</i><i>83</i><i>84</i><i>85</i><i>86</i><i>87</i><i>88</i><i>89</i><i>90</i><i>91</i><i>92</i><i>93</i><i>94</i><i>95</i><i>96</i><i>97</i><i>98</i><i>99</i><i>100</i><i>101</i><i>102</i><i>103</i><i>104</i><i>105</i><i>106</i><i>107</i><i>108</i><i>109</i><i>110</i><i>111</i><i>112</i><i>113</i><i>114</i><i>115</i><i>116</i><i>117</i><i>118</i><i>119</i><i>120</i><i>121</i><i>122</i><i>123</i><i>124</i><i>125</i><i>126</i><i>127</i><i>128</i><i>129</i><i>130</i><i>131</i><i>132</i><i>133</i><i>134</i><i>135</i><i>136</i><i>137</i><i>138</i><i>139</i><i>140</i><i>141</i><i>142</i><i>143</i><i>144</i><i>145</i><i>146</i><i>147</i><i>148</i><i>149</i><i>150</i><i>151</i><i>152</i><i>153</i><i>154</i><i>155</i><i>156</i><i>157</i><i>158</i><i>159</i><i>160</i><i>161</i><i>162</i><i>163</i><i>164</i><i>165</i><i>166</i><i>167</i><i>168</i><i>169</i><i>170</i><i>171</i><i>172</i><i>173</i><i>174</i><i>175</i><i>176</i><i>177</i><i>178</i><i>179</i><i>180</i><i>181</i><i>182</i><i>183</i><i>184</i><i>185</i><i>186</i><i>187</i><i>188</i><i>189</i><i>190</i><i>191</i><i>192</i><i>193</i><i>194</i><i>195</i><i>196</i><i>197</i><i>198</i><i>199</i><i>200</i><i>201</i><i>202</i><i>203</i><i>204</i><i>205</i><i>206</i><i>207</i><i>208</i><i>209</i><i>210</i><i>211</i><i>212</i><i>213</i><i>214</i><i>215</i><i>216</i><i>217</i><i>218</i><i>219</i><i>220</i><i>221</i><i>222</i><i>223</i><i>224</i><i>225</i><i>226</i><i>227</i><i>228</i><i>229</i><i>230</i><i>231</i><i>232</i><i>233</i><i>234</i><i>235</i><i>236</i><i>237</i><i>238</i><i>239</i><i>240</i><i>241</i><i>242</i><i>243</i><i>244</i><i>245</i><i>246</i><i>247</i><i>248</i><i>249</i><i>250</i><i>251</i><i>252</i><i>253</i><i>254</i><i>255</i><i>256</i><i>257</i><i>258</i><i>259</i><i>260</i><i>261</i><i>262</i><i>263</i><i>264</i><i>265</i><i>266</i><i>267</i><i>268</i><i>269</i><i>270</i><i>271</i><i>272</i><i>273</i><i>274</i><i>275</i><i>276</i><i>277</i><i>278</i><i>279</i><i>280</i><i>281</i><i>282</i><i>283</i><i>284</i><i>285</i><i>286</i><i>287</i><i>288</i><i>289</i><i>290</i><i>291</i><i>292</i><i>293</i><i>294</i><i>295</i><i>296</i><i>297</i><i>298</i><i>299</i><i>300</i><i>301</i><i>302</i><i>303</i><i>304</i><i>305</i><i>306</i><i>307</i><i>308</i><i>309</i><i>310</i><i>311</i><i>312</i><i>313</i><i>314</i><i>315</i><i>316</i><i>317</i><i>318</i><i>319</i><i>320</i><i>321</i><i>322</i><i>323</i><i>324</i><i>325</i><i>326</i><i>327</i><i>328</i><i>329</i><i>330</i><i>331</i><i>332</i><i>333</i><i>334</i><i>335</i><i>336</i><i>337</i><i>338</i><i>339</i><i>340</i><i>341</i><i>342</i><i>343</i><i>344</i><i>345</i><i>346</i><i>347</i><i>348</i><i>349</i><i>350</i><i>351</i><i>352</i><i>353</i><i>354</i><i>355</i><i>356</i><i>357</i><i>358</i><i>359</i><i>360</i><i>361</i><i>362</i><i>363</i><i>364</i><i>365</i><i>366</i><i>367</i><i>368</i><i>369</i><i>370</i><i>371</i><i>372</i><i>373</i><i>374</i><i>375</i><i>376</i><i>377</i><i>378</i><i>379</i><i>380</i><i>381</i><i>382</i><i>383</i><i>384</i><i>385</i><i>386</i><i>387</i><i>388</i><i>389</i><i>390</i><i>391</i><i>392</i><i>393</i><i>394</i><i>395</i><i>396</i><i>397</i><i>398</i><i>399</i><i>400</i><i>401</i><i>402</i><i>403</i><i>404</i><i>405</i><i>406</i><i>407</i><i>408</i><i>409</i><i>410</i><i>411</i><i>412</i><i>413</i><i>414</i><i>415</i><i>416</i><i>417</i><i>418</i><i>419</i><i>420</i><i>421</i><i>422</i><i>423</i><i>424</i><i>425</i><i>426</i><i>427</i><i>428</i><i>429</i><i>430</i><i>431</i><i>432</i><i>433</i><i>434</i><i>435</i><i>436</i><i>437</i><i>438</i><i>439</i><i>440</i><i>441</i><i>442</i><i>443</i><i>444</i><i>445</i><i>446</i><i>447</i><i>448</i><i>449</i><i>450</i><i>451</i><i>452</i><i>453</i><i>454</i><i>455</i><i>456</i><i>457</i><i>458</i><i>459</i><i>460</i><i>461</i><i>462</i><i>463</i><i>464</i><i>465</i><i>466</i><i>467</i><i>468</i><i>469</i><i>470</i><i>471</i><i>472</i><i>473</i><i>474</i><i>475</i><i>476</i><i>477</i><i>478</i><i>479</i><i>480</i><i>481</i><i>482</i><i>483</i><i>484</i><i>485</i><i>486</i><i>487</i><i>488</i><i>489</i><i>490</i><i>491</i><i>492</i><i>493</i><i>494</i><i>495</i><i>496</i><i>497</i><i>498</i><i>499</i><i>500</i><i>501</i><i>502</i><i>503</i><i>504</i><i>505</i><i>506</i><i>507</i><i>508</i><i>509</i><i>510</i><i>511</i><i>512</i><i>513</i><i>514</i><i>515</i><i>516</i><i>517</i><i>518</i><i>519</i><i>520</i><i>521</i><i>522</i><i>523</i><i>524</i><i>525</i><i>526</i><i>527</i><i>528</i><i>529</i><i>530</i><i>531</i><i>532</i><i>533</i><i>534</i><i>535</i><i>536</i><i>537</i><i>538</i><i>539</i><i>540</i><i>541</i><i>542</i><i>543</i><i>544</i><i>545</i><i>546</i><i>547</i><i>548</i><i>549</i><i>550</i><i>551</i><i>552</i><i>553</i><i>554</i><i>555</i><i>556</i><i>557</i><i>558</i><i>559</i><i>560</i><i>561</i><i>562</i><i>563</i><i>564</i><i>565</i><i>566</i><i>567</i><i>568</i><i>569</i><i>570</i><i>571</i><i>572</i><i>573</i><i>574</i><i>575</i><i>576</i><i>577</i><i>578</i><i>579</i><i>580</i><i>581</i><i>582</i><i>583</i><i>584</i><i>585</i><i>586</i><i>587</i><i>588</i><i>589</i><i>590</i><i>591</i><i>592</i><i>593</i><i>594</i><i>595</i><i>596</i><i>597</i><i>598</i><i>599</i><i>600</i><i>601</i><i>602</i><i>603</i><i>604</i><i>605</i><i>606</i><i>607</i><i>608</i><i>609</i><i>610</i><i>611</i><i>612</i><i>613</i><i>614</i><i>615</i><i>616</i><i>617</i><i>618</i><i>619</i><i>620</i><i>621</i><i>622</i><i>623</i><i>624</i><i>625</i><i>626</i><i>627</i><i>628</i><i>629</i><i>630</i><i>631</i><i>632</i><i>633</i><i>634</i><i>635</i><i>636</i><i>637</i><i>638</i><i>639</i><i>640</i><i>641</i><i>642</i><i>643</i><i>644</i><i>645</i><i>646</i><i>647</i><i>648</i><i>649</i><i>650</i><i>651</i><i>652</i><i>653</i><i>654</i><i>655</i><i>656</i><i>657</i><i>658</i><i>659</i><i>660</i><i>661</i><i>662</i><i>663</i><i>664</i><i>665</i><i>666</i><i>667</i><i>668</i><i>669</i><i>670</i><i>671</i><i>672</i><i>673</i><i>674</i><i>675</i><i>676</i><i>677</i><i>678</i><i>679</i><i>680</i><i>681</i><i>682</i><i>683</i><i>684</i><i>685</i><i>686</i><i>687</i><i>688</i><i>689</i><i>690</i><i>691</i><i>692</i><i>693</i><i>694</i><i>695</i><i>696</i><i>697</i><i>698</i><i>699</i><i>700</i><i>701</i><i>702</i><i>703</i><i>704</i><i>705</i><i>706</i><i>707</i><i>708</i><i>709</i><i>710</i><i>711</i><i>712</i><i>713</i><i>714</i><i>715</i><i>716</i><i>717</i><i>718</i><i>719</i><i>720</i><i>721</i><i>722</i><i>723</i><i>724</i><i>725</i><i>726</i><i>727</i><i>728</i><i>729</i><i>730</i><i>731</i><i>732</i><i>733</i><i>734</i><i>735</i><i>736</i><i>737</i><i>738</i><i>739</i><i>740</i><i>741</i><i>742</i><i>743</i><i>744</i><i>745</i><i>746</i><i>747</i><i>748</i><i>749</i><i>750</i><i>751</i><i>752</i><i>753</i><i>754</i><i>755</i><i>756</i><i>757</i><i>758</i><i>759</i><i>760</i><i>761</i><i>762</i><i>763</i><i>764</i><i>765</i><i>766</i><i>767</i><i>768</i><i>769</i><i>770</i><i>771</i><i>772</i><i>773</i><i>774</i><i>775</i><i>776</i><i>777</i><i>778</i><i>779</i><i>780</i><i>781</i><i>782</i><i>783</i><i>784</i><i>785</i><i>786</i><i>787</i><i>788</i><i>789</i><i>790</i><i>791</i><i>792</i><i>793</i><i>794</i></span><span itemscope itemtype="http://schema.org/SoftwareSourceCode"><meta itemprop="programmingLanguage" content="C" />&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;test&lt;/title&gt;
&lt;style type="text/css"&gt;
 body { font-family:Helvetica, sans-serif; font-size:10pt }
 h1 { font-size:14pt }
 .type { color: green}
 .code { border-collapse:collapse; width:100%; }
 .code { font-family: "Monospace", monospace; font-size:10pt }
 .code { line-height: 1.2em }
 .compound { display: inline-block; }
 .compound.level-0:hover { margin-left: 1px; border-left-style: solid; border-left-color: yellow; }
 .compound.level-1:hover { margin-left: 2px; border-left-style: solid; border-left-color: green; }
 .compound.level-2:hover { margin-left: 3px; border-left-style: solid; border-left-color: orange; }
 .comment { color: magenta; font-style: oblique }
 .string { color: purple; }
 .numeric { color: purple; }
 .char { color: purple; }
 .directive { color: blue; }
 .expansion { display: none; }
 .macro:hover .expansion { display: block; border: 2px solid #FF0000; padding: 2px; background-color:#FFF0F0; font-weight: normal;   -webkit-border-radius:5px;  -webkit-box-shadow:1px 1px 7px #000; position: absolute; top: -1em; left:10em; z-index: 1 } 
 .macro { color: darkmagenta; background-color:LemonChiffon; position: relative }
 .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
 .num { text-align:right; font-size:8pt }
 .num { color:#444444 }
 .line { padding-left: 1ex; border-left: 3px solid #ccc }
 .line { white-space: pre }
 .msg { -webkit-box-shadow:1px 1px 7px #000 }
 .msg { -webkit-border-radius:5px }
 .msg { font-family:Helvetica, sans-serif; font-size:8pt }
 .msg { float:left }
 .msg { padding:0.25em 1ex 0.25em 1ex }
 .msg { margin-top:10px; margin-bottom:10px }
 .msg { font-weight:bold }
 .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
 .msgT { padding:0x; spacing:0x }
 .msgEvent { background-color:#fff8b4; color:#000000 }
 .msgControl { background-color:#bbbbbb; color:#000000 }
 .mrange { background-color:#dfddf3 }
 .mrange { border-bottom:1px solid #6F9DBE }
 .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
 .PathIndex { -webkit-border-radius:8px }
 .PathIndexEvent { background-color:#bfba87 }
 .PathIndexControl { background-color:#8c8c8c }
 .PathNav a { text-decoration:none; font-size: larger }
 .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
 .CodeRemovalHint { background-color:#de1010 }
 .CodeRemovalHint { border-bottom:1px solid #6F9DBE }
 table.simpletable {
   padding: 5px;
   font-size:12pt;
   margin:20px;
   border-collapse: collapse; border-spacing: 0px;
 }
 td.rowname {
   text-align:right; font-weight:bold; color:#444444;
   padding-right:2ex; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;&lt;pre class='code'&gt;&lt;span class='directive'&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class='directive'&gt;#include "test.h"&lt;/span&gt;

&lt;span class='directive'&gt;# define TEST(foo) if (foo) { printf("foo"); }&lt;/span&gt;

&lt;span class='comment'&gt;/// Test comment.&lt;/span&gt;
&lt;div class='compound level-0'&gt;&lt;span class='type'&gt;int&lt;/span&gt; test() {
  printf(&lt;span class='string'&gt;"this is a test"&lt;/span&gt;);

&lt;div class='compound level-1'&gt;  {
    int a = &lt;span class='numeric'&gt;9&lt;/span&gt;;
    printf(&lt;span class='string'&gt;"this is another test: %d"&lt;/span&gt;, a);

  }&lt;/div&gt;

  return &lt;span class='numeric'&gt;3&lt;/span&gt;;
}&lt;/div&gt;

&lt;span class='comment'&gt;// This is a pre-existing comment.&lt;/span&gt;
&lt;span class='comment'&gt;/** Test comment */&lt;/span&gt;
&lt;div class='compound level-0'&gt;&lt;span class='type'&gt;int&lt;/span&gt; main(void) {
  int value = &lt;span class='numeric'&gt;12&lt;/span&gt;;
&lt;div class='compound level-1'&gt;  if (&lt;span class='numeric'&gt;1&lt;/span&gt;) { value = test();
&lt;div class='compound level-2'&gt;    if (value &amp;gt; &lt;span class='numeric'&gt;5&lt;/span&gt;) {
      printf(&lt;span class='string'&gt;"this is a second test"&lt;/span&gt;);
    }&lt;/div&gt;
  }&lt;/div&gt;
  TEST(value);
  return &lt;span class='numeric'&gt;0&lt;/span&gt;;
}&lt;/div&gt;
&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;test&lt;/title&gt;
&lt;style type="text/css"&gt;
 body { font-family:Helvetica, sans-serif; font-size:10pt }
 h1 { font-size:14pt }
 .type { color: green}
 .code { border-collapse:collapse; width:100%; }
 .code { font-family: "Monospace", monospace; font-size:10pt }
 .code { line-height: 1.2em }
 .compound { display: inline-block; }
 .compound.level-0:hover { margin-left: 1px; border-left-style: solid; border-left-color: yellow; }
 .compound.level-1:hover { margin-left: 2px; border-left-style: solid; border-left-color: green; }
 .compound.level-2:hover { margin-left: 3px; border-left-style: solid; border-left-color: orange; }
 .comment { color: magenta; font-style: oblique }
 .string { color: purple; }
 .numeric { color: purple; }
 .char { color: purple; }
 .directive { color: blue; }
 .expansion { display: none; }
 .macro:hover .expansion { display: block; border: 2px solid #FF0000; padding: 2px; background-color:#FFF0F0; font-weight: normal;   -webkit-border-radius:5px;  -webkit-box-shadow:1px 1px 7px #000; position: absolute; top: -1em; left:10em; z-index: 1 } 
 .macro { color: darkmagenta; background-color:LemonChiffon; position: relative }
 .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
 .num { text-align:right; font-size:8pt }
 .num { color:#444444 }
 .line { padding-left: 1ex; border-left: 3px solid #ccc }
 .line { white-space: pre }
 .msg { -webkit-box-shadow:1px 1px 7px #000 }
 .msg { -webkit-border-radius:5px }
 .msg { font-family:Helvetica, sans-serif; font-size:8pt }
 .msg { float:left }
 .msg { padding:0.25em 1ex 0.25em 1ex }
 .msg { margin-top:10px; margin-bottom:10px }
 .msg { font-weight:bold }
 .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
 .msgT { padding:0x; spacing:0x }
 .msgEvent { background-color:#fff8b4; color:#000000 }
 .msgControl { background-color:#bbbbbb; color:#000000 }
 .mrange { background-color:#dfddf3 }
 .mrange { border-bottom:1px solid #6F9DBE }
 .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
 .PathIndex { -webkit-border-radius:8px }
 .PathIndexEvent { background-color:#bfba87 }
 .PathIndexControl { background-color:#8c8c8c }
 .PathNav a { text-decoration:none; font-size: larger }
 .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
 .CodeRemovalHint { background-color:#de1010 }
 .CodeRemovalHint { border-bottom:1px solid #6F9DBE }
 table.simpletable {
   padding: 5px;
   font-size:12pt;
   margin:20px;
   border-collapse: collapse; border-spacing: 0px;
 }
 td.rowname {
   text-align:right; font-weight:bold; color:#444444;
   padding-right:2ex; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;&lt;pre class='code'&gt;&lt;span class='comment'&gt;// Copyright (c) 2013 Carlo Contavalli (ccontavalli@gmail.com).&lt;/span&gt;
&lt;span class='comment'&gt;// All rights reserved.&lt;/span&gt;
&lt;span class='comment'&gt;// &lt;/span&gt;
&lt;span class='comment'&gt;// Redistribution and use in source and binary forms, with or without&lt;/span&gt;
&lt;span class='comment'&gt;// modification, are permitted provided that the following conditions are met:&lt;/span&gt;
&lt;span class='comment'&gt;// &lt;/span&gt;
&lt;span class='comment'&gt;//    1. Redistributions of source code must retain the above copyright notice,&lt;/span&gt;
&lt;span class='comment'&gt;//    this list of conditions and the following disclaimer.&lt;/span&gt;
&lt;span class='comment'&gt;// &lt;/span&gt;
&lt;span class='comment'&gt;//    2. Redistributions in binary form must reproduce the above copyright&lt;/span&gt;
&lt;span class='comment'&gt;//    notice, this list of conditions and the following disclaimer in the&lt;/span&gt;
&lt;span class='comment'&gt;//    documentation and/or other materials provided with the distribution.&lt;/span&gt;
&lt;span class='comment'&gt;// &lt;/span&gt;
&lt;span class='comment'&gt;// THIS SOFTWARE IS PROVIDED BY Carlo Contavalli ''AS IS'' AND ANY EXPRESS OR&lt;/span&gt;
&lt;span class='comment'&gt;// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&lt;/span&gt;
&lt;span class='comment'&gt;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO&lt;/span&gt;
&lt;span class='comment'&gt;// EVENT SHALL Carlo Contavalli OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,&lt;/span&gt;
&lt;span class='comment'&gt;// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES&lt;/span&gt;
&lt;span class='comment'&gt;// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;&lt;/span&gt;
&lt;span class='comment'&gt;// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND&lt;/span&gt;
&lt;span class='comment'&gt;// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&lt;/span&gt;
&lt;span class='comment'&gt;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&lt;/span&gt;
&lt;span class='comment'&gt;// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&lt;/span&gt;
&lt;span class='comment'&gt;// &lt;/span&gt;
&lt;span class='comment'&gt;// The views and conclusions contained in the software and documentation are&lt;/span&gt;
&lt;span class='comment'&gt;// those of the authors and should not be interpreted as representing official&lt;/span&gt;
&lt;span class='comment'&gt;// policies, either expressed or implied, of Carlo Contavalli.&lt;/span&gt;

&lt;span class='comment'&gt;//------------------------------------------------------------------------------&lt;/span&gt;
&lt;span class='comment'&gt;// Clang rewriter sample. Demonstrates:&lt;/span&gt;
&lt;span class='comment'&gt;//&lt;/span&gt;
&lt;span class='comment'&gt;// * How to use RecursiveASTVisitor to find interesting AST nodes.&lt;/span&gt;
&lt;span class='comment'&gt;// * How to use the Rewriter API to rewrite the source code.&lt;/span&gt;
&lt;span class='comment'&gt;//&lt;/span&gt;
&lt;span class='comment'&gt;// Eli Bendersky (eliben@gmail.com)&lt;/span&gt;
&lt;span class='comment'&gt;// This code is in the public domain&lt;/span&gt;
&lt;span class='comment'&gt;//------------------------------------------------------------------------------&lt;/span&gt;
&lt;span class='directive'&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class='directive'&gt;#include &amp;lt;cstdio&amp;gt;&lt;/span&gt;
&lt;span class='directive'&gt;#include &amp;lt;memory&amp;gt;&lt;/span&gt;
&lt;span class='directive'&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span class='directive'&gt;#include &amp;lt;sstream&amp;gt;&lt;/span&gt;
&lt;span class='directive'&gt;#include &amp;lt;iomanip&amp;gt;&lt;/span&gt;

&lt;span class='directive'&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class='directive'&gt;#include &amp;lt;fstream&amp;gt;&lt;/span&gt;

&lt;span class='directive'&gt;#include &amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;
&lt;span class='directive'&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;

&lt;span class='directive'&gt;#include "clang/AST/ASTConsumer.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "clang/AST/RecursiveASTVisitor.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "clang/AST/ASTContext.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "clang/Basic/Diagnostic.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "clang/Basic/FileManager.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "clang/Basic/SourceManager.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "clang/Basic/TargetOptions.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "clang/Basic/TargetInfo.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "clang/Frontend/CompilerInstance.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "clang/Lex/Preprocessor.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "clang/Parse/ParseAST.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "clang/Rewrite/Core/Rewriter.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "clang/Rewrite/Core/HTMLRewrite.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "clang/Rewrite/Frontend/Rewriters.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "llvm/Support/Host.h"&lt;/span&gt;
&lt;span class='directive'&gt;#include "llvm/Support/raw_ostream.h"&lt;/span&gt;

&lt;span class='comment'&gt;// ./clang/lib/Frontend/Rewrite/HTMLPrint.cpp&lt;/span&gt;
&lt;span class='comment'&gt;// CommentVisitor&lt;/span&gt;

&lt;span class='comment'&gt;// Scoping:&lt;/span&gt;
&lt;span class='comment'&gt;//   - variable names: links are scoped. Clicking on hte name brings to the definition within the scope.&lt;/span&gt;
&lt;span class='comment'&gt;//   - function names: static in .cc are per file, non static are global.&lt;/span&gt;
&lt;span class='comment'&gt;//   - class definitions: in .cc file, they are per file?&lt;/span&gt;
&lt;span class='comment'&gt;//&lt;/span&gt;
&lt;span class='comment'&gt;// Two parts of the problem:&lt;/span&gt;
&lt;span class='comment'&gt;// - identifying position of objects, linking to objects.&lt;/span&gt;

using namespace clang;

void WrapIt(Rewriter&amp;amp; R, FileID FID, const char *title);
void RawHighlight(Rewriter &amp;amp;R, FileID FID, const Preprocessor &amp;amp;PP);

class Id {
 public:
  Id(std::string start) {
    if (!start.empty()) {
      base_ = start;
      base_.append(&lt;span class='string'&gt;"-"&lt;/span&gt;);
    }
  }

  std::string Get() {
    return base_ + std::to_string(id_++);
  }

 private:
  std::string base_ = &lt;span class='string'&gt;""&lt;/span&gt;;
  uint64_t id_ = &lt;span class='numeric'&gt;0&lt;/span&gt;;
};

&lt;span class='comment'&gt;// By implementing RecursiveASTVisitor, we can specify which AST nodes&lt;/span&gt;
&lt;span class='comment'&gt;// we're interested in by overriding relevant methods.&lt;/span&gt;
class MyASTVisitor : public RecursiveASTVisitor&amp;lt;MyASTVisitor&amp;gt; {
public:
  MyASTVisitor(Rewriter &amp;amp;rewriter, SourceManager&amp;amp; source_manager) : rewriter_(rewriter), source_manager_(source_manager) {}

  bool TraverseStmt(Stmt *s) {
    static int depth = &lt;span class='numeric'&gt;0&lt;/span&gt;;
    if (s &amp;amp;&amp;amp; isa&amp;lt;CompoundStmt&amp;gt;(s)) {
      auto *statement = cast&amp;lt;CompoundStmt&amp;gt;(s);

      &lt;span class='comment'&gt;// Find location with start of column.&lt;/span&gt;
      auto start = statement-&amp;gt;getLocStart();
      if (!start.isMacroID()) {
        auto fid = source_manager_.getMainFileID();
        auto line = source_manager_.getExpansionLineNumber(start);
        auto cache = source_manager_.getSLocEntry(fid).getFile().getContentCache();
        auto offset = cache-&amp;gt;SourceLineCache[line - &lt;span class='numeric'&gt;1&lt;/span&gt;];

        auto&amp;amp; buffer = rewriter_.getEditBuffer(fid);
        std::string div = &lt;span class='string'&gt;"&amp;lt;div class='compound level-"&lt;/span&gt; + std::to_string(depth) + &lt;span class='string'&gt;"'&amp;gt;"&lt;/span&gt;;
        buffer.InsertText(offset, div, false);
        &lt;span class='comment'&gt;//auto column = source_manager_.getSpellingColumnNumber(start);&lt;/span&gt;
        &lt;span class='comment'&gt;// auto cstart2 = source_manager_.translateLineCol(source_manager_.getMainFileID(), line, 0);&lt;/span&gt;
        &lt;span class='comment'&gt;// auto cstart = statement-&amp;gt;getLocStart();&lt;/span&gt;

        &lt;span class='comment'&gt;// rewriter_.InsertText(statement-&amp;gt;getLocStart(), "/**/");&lt;/span&gt;
        ++depth;
        &lt;span class='comment'&gt;// std::cerr &amp;lt;&amp;lt; "Entering compound " &amp;lt;&amp;lt; cstart.printToString(source_manager_) &amp;lt;&amp;lt; " or " &amp;lt;&amp;lt; cstart2.printToString(source_manager_) &amp;lt;&amp;lt; std::endl;&lt;/span&gt;
        auto result = RecursiveASTVisitor&amp;lt;MyASTVisitor&amp;gt;::TraverseStmt(s);
        --depth;
        rewriter_.InsertTextAfterToken(statement-&amp;gt;getLocEnd(), &lt;span class='string'&gt;"&amp;lt;/div&amp;gt;"&lt;/span&gt;);
        &lt;span class='comment'&gt;//std::cerr &amp;lt;&amp;lt; "Exiting compound " &amp;lt;&amp;lt; statement-&amp;gt;getLocEnd().printToString(source_manager_) &amp;lt;&amp;lt; std::endl;&lt;/span&gt;
        return result;
      }
    }

    return RecursiveASTVisitor&amp;lt;MyASTVisitor&amp;gt;::TraverseStmt(s);
  }

  bool VisitStmt(Stmt *s) {
    std::cerr &amp;lt;&amp;lt; &lt;span class='string'&gt;"Visiting statement "&lt;/span&gt; &amp;lt;&amp;lt; s-&amp;gt;getLocStart().printToString(source_manager_) &amp;lt;&amp;lt; std::endl;

&lt;span class='directive'&gt;#if 0&lt;/span&gt;
    &lt;span class='comment'&gt;// Only care about If statements.&lt;/span&gt;
    if (isa&amp;lt;IfStmt&amp;gt;(s)) {
      IfStmt *IfStatement = cast&amp;lt;IfStmt&amp;gt;(s);
      Stmt *Then = IfStatement-&amp;gt;getThen();

      rewriter_.InsertText(Then-&amp;gt;getLocStart(), &lt;span class='string'&gt;"// the 'if' part\n"&lt;/span&gt;, true,
                             true);

      Stmt *Else = IfStatement-&amp;gt;getElse();
      if (Else)
        rewriter_.InsertText(Else-&amp;gt;getLocStart(), &lt;span class='string'&gt;"// the 'else' part\n"&lt;/span&gt;,
                               true, true);
    }
&lt;span class='directive'&gt;#endif&lt;/span&gt;

    return true;
  }

  bool VisitBlockDecl(BlockDecl *d) {
    std::cerr &amp;lt;&amp;lt; &lt;span class='string'&gt;"Visiting block "&lt;/span&gt; &amp;lt;&amp;lt; std::endl;
    return true;
  }

  bool VisitFunctionDecl(FunctionDecl *f) {
    std::cerr &amp;lt;&amp;lt; &lt;span class='string'&gt;"Visiting function "&lt;/span&gt; &amp;lt;&amp;lt; std::endl;

    &lt;span class='comment'&gt;// Only function definitions (with bodies), not declarations.&lt;/span&gt;
    if (f-&amp;gt;hasBody()) {

      &lt;span class='comment'&gt;// Type name as string&lt;/span&gt;
      QualType QT = f-&amp;gt;getReturnType();
      std::string TypeStr = QT.getAsString();

      &lt;span class='comment'&gt;// Function name&lt;/span&gt;
      DeclarationName DeclName = f-&amp;gt;getNameInfo().getName();
      std::string FuncName = DeclName.getAsString();

      &lt;span class='comment'&gt;// Add comment before&lt;/span&gt;
&lt;span class='directive'&gt;#if 0&lt;/span&gt;
      std::stringstream SSBefore;
      SSBefore &amp;lt;&amp;lt; &lt;span class='string'&gt;"// Begin function "&lt;/span&gt; &amp;lt;&amp;lt; FuncName &amp;lt;&amp;lt; &lt;span class='string'&gt;" returning "&lt;/span&gt; &amp;lt;&amp;lt; TypeStr
               &amp;lt;&amp;lt; &lt;span class='string'&gt;"\n"&lt;/span&gt;;
      SourceLocation source_location = f-&amp;gt;getSourceRange().getBegin();
      rewriter_.InsertText(source_location, SSBefore.str(), true, true);
&lt;span class='directive'&gt;#endif&lt;/span&gt;

&lt;span class='directive'&gt;#if 0&lt;/span&gt;
      Stmt *FuncBody = f-&amp;gt;getBody();
      &lt;span class='comment'&gt;// And after&lt;/span&gt;
      std::stringstream SSAfter;
      SSAfter &amp;lt;&amp;lt; &lt;span class='string'&gt;"\n// End function "&lt;/span&gt; &amp;lt;&amp;lt; FuncName;
      auto source_location = FuncBody-&amp;gt;getLocEnd().getLocWithOffset(&lt;span class='numeric'&gt;1&lt;/span&gt;);
      rewriter_.InsertText(source_location, SSAfter.str(), true, true);
&lt;span class='directive'&gt;#endif&lt;/span&gt;

      auto source_location = f-&amp;gt;getReturnTypeSourceRange().getEnd();
      rewriter_.InsertTextAfterToken(source_location, &lt;span class='string'&gt;"&amp;lt;/span&amp;gt;"&lt;/span&gt;);
      source_location = f-&amp;gt;getReturnTypeSourceRange().getBegin();
      rewriter_.InsertTextBefore(source_location, &lt;span class='string'&gt;"&amp;lt;span class='type'&amp;gt;"&lt;/span&gt;);
    }

    return true;
  }

private:
  &lt;span class='comment'&gt;//Id id_;&lt;/span&gt;
  Rewriter &amp;amp;rewriter_;
  SourceManager &amp;amp;source_manager_;
};

&lt;span class='comment'&gt;// Implementation of the ASTConsumer interface for reading an AST produced&lt;/span&gt;
&lt;span class='comment'&gt;// by the Clang parser.&lt;/span&gt;
class MyASTConsumer : public ASTConsumer {
public:
  MyASTConsumer(CompilerInstance&amp;amp; ci, Rewriter &amp;amp;rewriter, SourceManager &amp;amp;source_manager) : ci_(ci), rewriter_(rewriter), visitor_(rewriter, source_manager) {}

  &lt;span class='comment'&gt;// Override the method that gets called for each parsed top-level&lt;/span&gt;
  &lt;span class='comment'&gt;// declaration.&lt;/span&gt;
  bool HandleTopLevelDecl(DeclGroupRef DR) override {
    for (DeclGroupRef::iterator b = DR.begin(), e = DR.end(); b != e; ++b)
      &lt;span class='comment'&gt;// Traverse the declaration using our AST visitor.&lt;/span&gt;
      visitor_.TraverseDecl(*b);
    return true;
  }

  void HandleTranslationUnit(ASTContext&amp;amp; ctx) override {
    const auto&amp;amp; sm = ctx.getSourceManager();
    const auto&amp;amp; fid = sm.getMainFileID();

    WrapIt(rewriter_, fid, &lt;span class='string'&gt;"test"&lt;/span&gt;);
    RawHighlight(rewriter_, fid, ci_.getPreprocessor());

    html::EscapeText(rewriter_, fid, false, true);

    const auto&amp;amp; location = sm.getLocForStartOfFile(sm.getMainFileID());
    std::cerr &amp;lt;&amp;lt; &lt;span class='string'&gt;"HANDLE TU "&lt;/span&gt; &amp;lt;&amp;lt; fid.getHashValue()
      &amp;lt;&amp;lt; &lt;span class='string'&gt;" "&lt;/span&gt; &amp;lt;&amp;lt; location.printToString(sm) &amp;lt;&amp;lt; std::endl;
  }

private:
  CompilerInstance&amp;amp; ci_;
  Rewriter&amp;amp; rewriter_;
  MyASTVisitor visitor_;
};


&lt;span class='type'&gt;void&lt;/span&gt; HighlightRange(RewriteBuffer &amp;amp;RB, unsigned B, unsigned E,
                          const char *BufferStart,
&lt;div class='compound level-0'&gt;                          const char *StartTag, const char *EndTag) {
  &lt;span class='comment'&gt;// Insert the tag at the absolute start/end of the range.&lt;/span&gt;
  RB.InsertTextAfter(B, StartTag);
  RB.InsertTextBefore(E, EndTag);

  &lt;span class='comment'&gt;// Scan the range to see if there is a \r or \n.  If so, and if the line is&lt;/span&gt;
  &lt;span class='comment'&gt;// not blank, insert tags on that line as well.&lt;/span&gt;
  bool HadOpenTag = true;

  unsigned LastNonWhiteSpace = B;
&lt;div class='compound level-1'&gt;  for (unsigned i = B; i != E; ++i) {
    switch (BufferStart[i]) {
    case &lt;span class='char'&gt;'\r'&lt;/span&gt;:
    case &lt;span class='char'&gt;'\n'&lt;/span&gt;:
      &lt;span class='comment'&gt;// Okay, we found a newline in the range.  If we have an open tag, we need&lt;/span&gt;
      &lt;span class='comment'&gt;// to insert a close tag at the first non-whitespace before the newline.&lt;/span&gt;
      if (HadOpenTag)
        RB.InsertTextBefore(LastNonWhiteSpace+&lt;span class='numeric'&gt;1&lt;/span&gt;, EndTag);

      &lt;span class='comment'&gt;// Instead of inserting an open tag immediately after the newline, we&lt;/span&gt;
      &lt;span class='comment'&gt;// wait until we see a non-whitespace character.  This prevents us from&lt;/span&gt;
      &lt;span class='comment'&gt;// inserting tags around blank lines, and also allows the open tag to&lt;/span&gt;
      &lt;span class='comment'&gt;// be put *after* whitespace on a non-blank line.&lt;/span&gt;
      HadOpenTag = false;
      break;
    case &lt;span class='char'&gt;'\0'&lt;/span&gt;:
    case &lt;span class='char'&gt;' '&lt;/span&gt;:
    case &lt;span class='char'&gt;'\t'&lt;/span&gt;:
    case &lt;span class='char'&gt;'\f'&lt;/span&gt;:
    case &lt;span class='char'&gt;'\v'&lt;/span&gt;:
      &lt;span class='comment'&gt;// Ignore whitespace.&lt;/span&gt;
      break;

    default:
      &lt;span class='comment'&gt;// If there is no tag open, do it now.&lt;/span&gt;
      if (!HadOpenTag) {
        RB.InsertTextAfter(i, StartTag);
        HadOpenTag = true;
      }

      &lt;span class='comment'&gt;// Remember this character.&lt;/span&gt;
      LastNonWhiteSpace = i;
      break;
    }
  }&lt;/div&gt;
}&lt;/div&gt;
&lt;span class='type'&gt;void&lt;/span&gt; HighlightRange(Rewriter &amp;amp;R, SourceLocation B, SourceLocation E,
&lt;div class='compound level-0'&gt;                          const char *StartTag, const char *EndTag) {
  SourceManager &amp;amp;SM = R.getSourceMgr();
  B = SM.getExpansionLoc(B);
  E = SM.getExpansionLoc(E);
  FileID FID = SM.getFileID(B);
  assert(SM.getFileID(E) == FID &amp;amp;&amp;amp; &lt;span class='string'&gt;"B/E not in the same file!"&lt;/span&gt;);

  unsigned BOffset = SM.getFileOffset(B);
  unsigned EOffset = SM.getFileOffset(E);

  &lt;span class='comment'&gt;// Include the whole end token in the range.&lt;/span&gt;
  EOffset += Lexer::MeasureTokenLength(E, R.getSourceMgr(), R.getLangOpts());

  bool Invalid = false;
  const char *BufferStart = SM.getBufferData(FID, &amp;amp;Invalid).data();
  if (Invalid)
    return;
  
  HighlightRange(R.getEditBuffer(FID), BOffset, EOffset,
                 BufferStart, StartTag, EndTag);
}&lt;/div&gt;
&lt;div class='compound level-0'&gt;&lt;span class='type'&gt;void&lt;/span&gt; RawHighlight(Rewriter &amp;amp;R, FileID FID, const Preprocessor &amp;amp;PP) {
  RewriteBuffer &amp;amp;RB = R.getEditBuffer(FID);

  const SourceManager &amp;amp;SM = PP.getSourceManager();
  const llvm::MemoryBuffer *FromFile = SM.getBuffer(FID);
  Lexer L(FID, FromFile, SM, PP.getLangOpts());
  const char *BufferStart = L.getBuffer().data();

  &lt;span class='comment'&gt;// Inform the preprocessor that we want to retain comments as tokens, so we&lt;/span&gt;
  &lt;span class='comment'&gt;// can highlight them.&lt;/span&gt;
  L.SetCommentRetentionState(true);

  &lt;span class='comment'&gt;// Lex all the tokens in raw mode, to avoid entering #includes or expanding&lt;/span&gt;
  &lt;span class='comment'&gt;// macros.&lt;/span&gt;
  Token Tok;
  L.LexFromRawLexer(Tok);

  while (Tok.isNot(tok::eof)) {
    unsigned TokOffs = SM.getFileOffset(Tok.getLocation());
    unsigned TokLen = Tok.getLength();
    switch (Tok.getKind()) {
    default: break;
    case tok::comment:
      HighlightRange(RB, TokOffs, TokOffs+TokLen, BufferStart,
                     &lt;span class='string'&gt;"&amp;lt;span class='comment'&amp;gt;"&lt;/span&gt;, &lt;span class='string'&gt;"&amp;lt;/span&amp;gt;"&lt;/span&gt;);
      break;
    case tok::utf8_string_literal:
      &lt;span class='comment'&gt;// Chop off the u part of u8 prefix&lt;/span&gt;
      ++TokOffs;
      --TokLen;
      &lt;span class='comment'&gt;// FALL THROUGH to chop the 8&lt;/span&gt;
    case tok::wide_string_literal:
    case tok::utf16_string_literal:
    case tok::utf32_string_literal:
      &lt;span class='comment'&gt;// Chop off the L, u, U or 8 prefix&lt;/span&gt;
      ++TokOffs;
      --TokLen;
      &lt;span class='comment'&gt;// FALL THROUGH.&lt;/span&gt;
    case tok::string_literal:
      &lt;span class='comment'&gt;// FIXME: Exclude the optional ud-suffix from the highlighted range.&lt;/span&gt;
      HighlightRange(RB, TokOffs, TokOffs+TokLen, BufferStart,
                     &lt;span class='string'&gt;"&amp;lt;span class='string'&amp;gt;"&lt;/span&gt;, &lt;span class='string'&gt;"&amp;lt;/span&amp;gt;"&lt;/span&gt;);
      break;
    case tok::numeric_constant:
      HighlightRange(RB, TokOffs, TokOffs+TokLen, BufferStart,
                     &lt;span class='string'&gt;"&amp;lt;span class='numeric'&amp;gt;"&lt;/span&gt;, &lt;span class='string'&gt;"&amp;lt;/span&amp;gt;"&lt;/span&gt;);
      break;
    case tok::utf8_char_constant:
      ++TokOffs;
      --TokLen;
    case tok::wide_char_constant:
    case tok::utf16_char_constant:
    case tok::utf32_char_constant:
      &lt;span class='comment'&gt;// Chop off the L, u, U or 8 prefix&lt;/span&gt;
      ++TokOffs;
      --TokLen;
    case tok::char_constant:
      HighlightRange(RB, TokOffs, TokOffs+TokLen, BufferStart,
                     &lt;span class='string'&gt;"&amp;lt;span class='char'&amp;gt;"&lt;/span&gt;, &lt;span class='string'&gt;"&amp;lt;/span&amp;gt;"&lt;/span&gt;);
      break;
    case tok::hash: {
      &lt;span class='comment'&gt;// If this is a preprocessor directive, all tokens to end of line are too.&lt;/span&gt;
      if (!Tok.isAtStartOfLine())
        break;

      &lt;span class='comment'&gt;// Eat all of the tokens until we get to the next one at the start of&lt;/span&gt;
      &lt;span class='comment'&gt;// line.&lt;/span&gt;
      unsigned TokEnd = TokOffs+TokLen;
      L.LexFromRawLexer(Tok);
      while (!Tok.isAtStartOfLine() &amp;amp;&amp;amp; Tok.isNot(tok::eof)) {
        TokEnd = SM.getFileOffset(Tok.getLocation())+Tok.getLength();
        L.LexFromRawLexer(Tok);
      }

      &lt;span class='comment'&gt;// Find end of line.  This is a hack.&lt;/span&gt;
      HighlightRange(RB, TokOffs, TokEnd, BufferStart,
                     &lt;span class='string'&gt;"&amp;lt;span class='directive'&amp;gt;"&lt;/span&gt;, &lt;span class='string'&gt;"&amp;lt;/span&amp;gt;"&lt;/span&gt;);

      &lt;span class='comment'&gt;// Don't skip the next token.&lt;/span&gt;
      continue;
    }
    }

    L.LexFromRawLexer(Tok);
  }
}&lt;/div&gt;



&lt;div class='compound level-0'&gt;&lt;span class='type'&gt;void&lt;/span&gt; WrapIt(Rewriter&amp;amp; R, FileID FID, const char *title) {

  const llvm::MemoryBuffer *Buf = R.getSourceMgr().getBuffer(FID);
  const char* FileStart = Buf-&amp;gt;getBufferStart();
  const char* FileEnd = Buf-&amp;gt;getBufferEnd();

  SourceLocation StartLoc = R.getSourceMgr().getLocForStartOfFile(FID);
  SourceLocation EndLoc = StartLoc.getLocWithOffset(FileEnd-FileStart);

  std::string s;
  llvm::raw_string_ostream os(s);
  os &amp;lt;&amp;lt; &lt;span class='string'&gt;"&amp;lt;!doctype html&amp;gt;\n"&lt;/span&gt; &lt;span class='comment'&gt;// Use HTML 5 doctype&lt;/span&gt;
        &lt;span class='string'&gt;"&amp;lt;html&amp;gt;\n&amp;lt;head&amp;gt;\n"&lt;/span&gt;;

  if (title)
    os &amp;lt;&amp;lt; &lt;span class='string'&gt;"&amp;lt;title&amp;gt;"&lt;/span&gt; &amp;lt;&amp;lt; html::EscapeText(title) &amp;lt;&amp;lt; &lt;span class='string'&gt;"&amp;lt;/title&amp;gt;\n"&lt;/span&gt;;

  os &amp;lt;&amp;lt; &lt;span class='string'&gt;"&amp;lt;style type=\"text/css\"&amp;gt;\n"&lt;/span&gt;
      &lt;span class='comment'&gt;// " body { color:#000000; background-color:#ffffff }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" body { font-family:Helvetica, sans-serif; font-size:10pt }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" h1 { font-size:14pt }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .type { color: green}\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .code { border-collapse:collapse; width:100%; }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .code { font-family: \"Monospace\", monospace; font-size:10pt }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .code { line-height: 1.2em }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .compound { display: inline-block; }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .compound.level-0:hover { margin-left: 1px; border-left-style: solid; border-left-color: yellow; }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .compound.level-1:hover { margin-left: 2px; border-left-style: solid; border-left-color: green; }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .compound.level-2:hover { margin-left: 3px; border-left-style: solid; border-left-color: orange; }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .comment { color: magenta; font-style: oblique }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .string { color: purple; }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .numeric { color: purple; }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .char { color: purple; }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .directive { color: blue; }\n"&lt;/span&gt;

      &lt;span class='comment'&gt;// Macro expansions.&lt;/span&gt;
      &lt;span class='string'&gt;" .expansion { display: none; }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .macro:hover .expansion { display: block; border: 2px solid #FF0000; "&lt;/span&gt;
          &lt;span class='string'&gt;"padding: 2px; background-color:#FFF0F0; font-weight: normal; "&lt;/span&gt;
          &lt;span class='string'&gt;"  -webkit-border-radius:5px;  -webkit-box-shadow:1px 1px 7px #000; "&lt;/span&gt;
          &lt;span class='string'&gt;"position: absolute; top: -1em; left:10em; z-index: 1 } \n"&lt;/span&gt;
      &lt;span class='string'&gt;" .macro { color: darkmagenta; background-color:LemonChiffon;"&lt;/span&gt;
             &lt;span class='comment'&gt;// Macros are position: relative to provide base for expansions.&lt;/span&gt;
             &lt;span class='string'&gt;" position: relative }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .num { text-align:right; font-size:8pt }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .num { color:#444444 }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .line { padding-left: 1ex; border-left: 3px solid #ccc }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .line { white-space: pre }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .msg { -webkit-box-shadow:1px 1px 7px #000 }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .msg { -webkit-border-radius:5px }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .msg { font-family:Helvetica, sans-serif; font-size:8pt }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .msg { float:left }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .msg { padding:0.25em 1ex 0.25em 1ex }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .msg { margin-top:10px; margin-bottom:10px }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .msg { font-weight:bold }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .msgT { padding:0x; spacing:0x }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .msgEvent { background-color:#fff8b4; color:#000000 }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .msgControl { background-color:#bbbbbb; color:#000000 }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .mrange { background-color:#dfddf3 }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .mrange { border-bottom:1px solid #6F9DBE }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .PathIndex { font-weight: bold; padding:0px 5px; "&lt;/span&gt;
        &lt;span class='string'&gt;"margin-right:5px; }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .PathIndex { -webkit-border-radius:8px }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .PathIndexEvent { background-color:#bfba87 }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .PathIndexControl { background-color:#8c8c8c }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .PathNav a { text-decoration:none; font-size: larger }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .CodeRemovalHint { background-color:#de1010 }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" .CodeRemovalHint { border-bottom:1px solid #6F9DBE }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" table.simpletable {\n"&lt;/span&gt;
      &lt;span class='string'&gt;"   padding: 5px;\n"&lt;/span&gt;
      &lt;span class='string'&gt;"   font-size:12pt;\n"&lt;/span&gt;
      &lt;span class='string'&gt;"   margin:20px;\n"&lt;/span&gt;
      &lt;span class='string'&gt;"   border-collapse: collapse; border-spacing: 0px;\n"&lt;/span&gt;
      &lt;span class='string'&gt;" }\n"&lt;/span&gt;
      &lt;span class='string'&gt;" td.rowname {\n"&lt;/span&gt;
      &lt;span class='string'&gt;"   text-align:right; font-weight:bold; color:#444444;\n"&lt;/span&gt;
      &lt;span class='string'&gt;"   padding-right:2ex; }\n"&lt;/span&gt;
      &lt;span class='string'&gt;"&amp;lt;/style&amp;gt;\n&amp;lt;/head&amp;gt;\n&amp;lt;body&amp;gt;&amp;lt;pre class='code'&amp;gt;"&lt;/span&gt;;

  &lt;span class='comment'&gt;// Generate header&lt;/span&gt;
  R.InsertTextBefore(StartLoc, os.str());
  &lt;span class='comment'&gt;// Generate footer&lt;/span&gt;

  R.InsertTextAfter(EndLoc, &lt;span class='string'&gt;"&amp;lt;/pre&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;\n"&lt;/span&gt;);
}&lt;/div&gt;

template&amp;lt; typename T &amp;gt;
std::string ToHex( T i )
{
    std::stringstream stream;
    stream 
           &amp;lt;&amp;lt; std::setfill (&lt;span class='char'&gt;'0'&lt;/span&gt;) &amp;lt;&amp;lt; std::setw(sizeof(T)*&lt;span class='numeric'&gt;2&lt;/span&gt;) 
           &amp;lt;&amp;lt; std::hex &amp;lt;&amp;lt; i;
    return stream.str();
}

std::string Join(const std::initializer_list&amp;lt;std::string&amp;gt;&amp;amp; paths) {
  std::string result;
  if (!paths.size())
    return result;

  &lt;span class='comment'&gt;// Append all elements of the list, followed by a "/".&lt;/span&gt;
  for (const auto&amp;amp; path : paths) {
    result.append(path);
    result.append(&lt;span class='string'&gt;"/"&lt;/span&gt;);
  }

  &lt;span class='comment'&gt;// Remove last trailing "/".&lt;/span&gt;
  result.resize(result.size() - &lt;span class='numeric'&gt;1&lt;/span&gt;);
  return result;
}

std::string MakeSourcePath(unsigned hash) {
  std::string hex = ToHex(hash);
  auto end = hex.length();
  return Join({&lt;span class='string'&gt;"output"&lt;/span&gt;, &lt;span class='string'&gt;"sources"&lt;/span&gt;, hex.substr(end - &lt;span class='numeric'&gt;2&lt;/span&gt;), hex.substr(&lt;span class='numeric'&gt;0&lt;/span&gt;, end - &lt;span class='numeric'&gt;2&lt;/span&gt;) + &lt;span class='string'&gt;".html"&lt;/span&gt;});
}

&lt;div class='compound level-0'&gt;bool MakeDirs(const std::string&amp;amp; path, int mode) {
  std::string copy(path);

  for (std::size_t index = &lt;span class='numeric'&gt;1&lt;/span&gt;;
       (index = copy.find(&lt;span class='char'&gt;'/'&lt;/span&gt;, index)) != std::string::npos;) {
    copy[index] = &lt;span class='char'&gt;'\0'&lt;/span&gt;;
    if (!mkdir(copy.c_str(), mode) &amp;amp;&amp;amp; errno != EEXIST)
      return false;

    copy[index] = &lt;span class='char'&gt;'/'&lt;/span&gt;;
    index = index + &lt;span class='numeric'&gt;1&lt;/span&gt;;
  }
  return true;
}&lt;/div&gt;


&lt;div class='compound level-0'&gt;&lt;span class='type'&gt;int&lt;/span&gt; main(int argc, char *argv[]) {
&lt;div class='compound level-1'&gt;  if (argc &amp;lt; &lt;span class='numeric'&gt;2&lt;/span&gt;) {
    llvm::errs() &amp;lt;&amp;lt; &lt;span class='string'&gt;"Usage: rewritersample &amp;lt;filename&amp;gt;...\n"&lt;/span&gt;;
    return &lt;span class='numeric'&gt;1&lt;/span&gt;;
  }&lt;/div&gt;

  &lt;span class='comment'&gt;// CompilerInstance will hold the instance of the Clang compiler for us,&lt;/span&gt;
  &lt;span class='comment'&gt;// managing the various objects needed to run the compiler.&lt;/span&gt;
  CompilerInstance ci;
  ci.createDiagnostics();

  LangOptions &amp;amp;lo = ci.getLangOpts();
  &lt;span class='comment'&gt;// lo.CPlusPlus = 1;&lt;/span&gt;

  &lt;span class='comment'&gt;// Initialize target info with the default triple for our platform.&lt;/span&gt;
  auto target_options = std::make_shared&amp;lt;TargetOptions&amp;gt;();
  target_options-&amp;gt;Triple = llvm::sys::getDefaultTargetTriple();
  TargetInfo *target_info =
      TargetInfo::CreateTargetInfo(ci.getDiagnostics(), target_options);
  ci.setTarget(target_info);

  ci.createFileManager();
  FileManager &amp;amp;file_mgr = ci.getFileManager();
  ci.createSourceManager(file_mgr);
  SourceManager &amp;amp;source_mgr = ci.getSourceManager();
  &lt;span class='comment'&gt;//ci.createPreprocessor(TU_Module);&lt;/span&gt;
  ci.createPreprocessor(TU_Complete);
  ci.createASTContext();

  &lt;span class='comment'&gt;// A Rewriter helps us manage the code rewriting task.&lt;/span&gt;
  Rewriter rewriter;
  rewriter.setSourceMgr(source_mgr, ci.getLangOpts());

  &lt;span class='comment'&gt;// Create an AST consumer instance which is going to get called by&lt;/span&gt;
  &lt;span class='comment'&gt;// ParseAST.&lt;/span&gt;
  MyASTConsumer consumer(ci, rewriter, source_mgr);

&lt;div class='compound level-1'&gt;  for (int i = &lt;span class='numeric'&gt;1&lt;/span&gt;; i &amp;lt; argc; ++i) {
    &lt;span class='comment'&gt;// Set the main file handled by the source manager to the input file.&lt;/span&gt;
    const FileEntry *input = file_mgr.getFile(argv[i]);
    auto fid = source_mgr.createFileID(input, SourceLocation(), SrcMgr::C_User);
    source_mgr.setMainFileID(fid);
    ci.getDiagnosticClient().BeginSourceFile(ci.getLangOpts(), &amp;amp;ci.getPreprocessor());

    auto fib = source_mgr.fileinfo_begin();
    auto fie = source_mgr.fileinfo_end();
&lt;div class='compound level-2'&gt;    for (int i = &lt;span class='numeric'&gt;0&lt;/span&gt;; fib != fie; ++fib, ++i) {
      std::cerr &amp;lt;&amp;lt; &lt;span class='string'&gt;"FIB "&lt;/span&gt; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;
    }&lt;/div&gt;

    &lt;span class='comment'&gt;// Parse the file to AST, registering our consumer as the AST consumer.&lt;/span&gt;
    ParseAST(ci.getPreprocessor(), &amp;amp;consumer, ci.getASTContext(), false &lt;span class='comment'&gt;/* Print Stats */&lt;/span&gt;);

    fib = source_mgr.fileinfo_begin();
    fie = source_mgr.fileinfo_end();
&lt;div class='compound level-2'&gt;    for (int i = &lt;span class='numeric'&gt;0&lt;/span&gt;; fib != fie; ++fib, ++i) {
      std::cerr &amp;lt;&amp;lt; &lt;span class='string'&gt;"FIB "&lt;/span&gt; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;
    }&lt;/div&gt;


    &lt;span class='comment'&gt;// NOTES, about handling comments:&lt;/span&gt;
    &lt;span class='comment'&gt;// auto *pp = ci.getPreprocessor();&lt;/span&gt;
    &lt;span class='comment'&gt;// pp-&amp;gt;addCommentHandler();&lt;/span&gt;
    &lt;span class='comment'&gt;// &lt;/span&gt;



    &lt;span class='comment'&gt;// Check comments. THIS ONLY CAPTURES doxygen comments.&lt;/span&gt;
    auto&amp;amp; ast_context = ci.getASTContext();
&lt;span class='comment'&gt;//    ast_context.getExternalSource()-&amp;gt;ReadComments();&lt;/span&gt;
    const auto&amp;amp; comments = ast_context.getRawCommentList().getComments();
    std::cerr &amp;lt;&amp;lt; &lt;span class='string'&gt;"DUMPING COMMENTS"&lt;/span&gt; &amp;lt;&amp;lt; std::endl;
    for (auto&amp;amp; comment : comments) 
      std::cerr &amp;lt;&amp;lt; &lt;span class='string'&gt;"COMMENT "&lt;/span&gt; &amp;lt;&amp;lt; comment-&amp;gt;getRawText(source_mgr).str() &amp;lt;&amp;lt; std::endl;
    std::cerr &amp;lt;&amp;lt; &lt;span class='string'&gt;"DONE COMMENTS"&lt;/span&gt; &amp;lt;&amp;lt; std::endl;

    auto path = MakeSourcePath(fid.getHashValue());
    std::cerr &amp;lt;&amp;lt; &lt;span class='string'&gt;"PATH "&lt;/span&gt; &amp;lt;&amp;lt; path &amp;lt;&amp;lt; std::endl;
&lt;div class='compound level-2'&gt;    if (!MakeDirs(path, &lt;span class='numeric'&gt;0777&lt;/span&gt;)) {
      std::cerr &amp;lt;&amp;lt; &lt;span class='string'&gt;"FAILED TO MAKE DIRS"&lt;/span&gt; &amp;lt;&amp;lt; std::endl;
      return &lt;span class='numeric'&gt;5&lt;/span&gt;;
    }&lt;/div&gt;

    &lt;span class='comment'&gt;// At this point the rewriter's buffer should be full with the rewritten&lt;/span&gt;
    &lt;span class='comment'&gt;// file contents.&lt;/span&gt;
    const RewriteBuffer *RewriteBuf = rewriter.getRewriteBufferFor(fid);
    llvm::outs() &amp;lt;&amp;lt; std::string(RewriteBuf-&amp;gt;begin(), RewriteBuf-&amp;gt;end());

    std::ofstream myfile;
    myfile.open(path);
    myfile &amp;lt;&amp;lt; std::string(RewriteBuf-&amp;gt;begin(), RewriteBuf-&amp;gt;end());
  }&lt;/div&gt;

  return &lt;span class='numeric'&gt;0&lt;/span&gt;;
}&lt;/div&gt;
&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;
</span><span class='cl'></span></pre></div><script src="../../globals.js"></script><script src="../../static/jquery.min.js"></script><script src="../../static/bootstrap/js/bootstrap.min.js"></script><script src="../../static/bootstrap/js/dropdowns-enhancement.js"></script><script src="../../static/animated-modal/animatedModal.js"></script><script src="../../static/jquery.autocomplete.js"></script><script src="../../static/js.cookie.js"></script><script src="../../static/local.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-40501108-2', 'auto');ga('send', 'pageview');</script></body></html>