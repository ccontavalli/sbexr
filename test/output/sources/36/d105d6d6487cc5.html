<!DOCTYPE html><html lang='en'><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>test output - /usr/include/wchar.h</title><link href="../../static/bootstrap/css/bootstrap.min.css" rel="stylesheet"><link href="../../static/bootstrap/css/dropdowns-enhancement.min.css" rel="stylesheet"><link href="../../static/animated-modal/animate.min.css" rel="stylesheet"><link href="../../static/font-awesome/css/font-awesome.min.css" rel="stylesheet"><link href="../../static/style.css" rel="stylesheet"></head><body><div class="container-fluid"><div class="container"><nav class="navbar navbar-default navbar-fixed-top"><div class="container-fluid" id="navbar"><!-- Brand and toggle get grouped for better mobile display --><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><span class="navbar-brand" style="padding-top: 8px"><ol id="path" itemscope itemtype="http://schema.org/BreadcrumbList"><!-- ROOT DIRECTORY --><li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem"><a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="../06/416cc91f3e3d90.html"><i itemprop="image" alt="root" class="glyphicon glyphicon-hdd" style="vertical-align: middle"></i>&nbsp;</a></li><li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem"><a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="../60/7abc7e1c17ae25.html"><span itemprop="name">usr</span></a></li><li itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem"><a itemscope itemtype="http://schema.org/Thing" itemprop="item" href="../19/901c5d9478e5ce.html"><span itemprop="name">include</span></a></li></ol>wchar.h</span></div><!-- Collect the nav links, forms, and other content for toggling --><!-- mostly taken from http://www.bootply.com/t7O3HSGlbc --><div class="collapse navbar-collapse" id="main-navbar"><div class="form-group" style="margin-top: 8px; margin-bottom: 0px;"><div class="input-group"><div class="input-group-btn"><button class="btn btn-default correct-height" data-label-placement><i class="glyphicon glyphicon-console data-label"></i></button><button data-toggle="dropdown" class="btn btn-default dropdown-toggle correct-height"><span class="caret"></span> </button><ul class="dropdown-menu"><li><input type="radio" id="sb-symbol" name="sb" value="symbol" checked><label for="sb-symbol"><i class="glyphicon glyphicon-console data-label"></i> Symbol</label></li><li><input type="radio" id="sb-file" name="sb" value="file"><label for="sb-file"><i class="glyphicon glyphicon-file data-label"></i> File</label></li><li><input type="radio" id="sb-text" name="sb" value="text"><label for="sb-text"><i class="glyphicon glyphicon-text-background data-label"></i> Text</label></li><li><input type="radio" id="sb-line" name="sb" value="line"><label for="sb-line"><i class="glyphicon glyphicon-indent-left data-label"></i> Line</label></li></ul></div><input type="text" name="search" id="searchbox-symbol" class="form-control" placeholder="Search symbol (std::list, list, kfree_skb, any full or partial variable/class/function/... name)"><input type="text" name="search" id="searchbox-file" class="form-control hidden" placeholder="Search file (/usr/include/alloca.h, alloca.h, any full or partial path)"><input type="text" name="search" id="searchbox-text" class="form-control hidden" placeholder="Search text (content of comments, strings, full text search over the source code)"><input type="text" name="search" id="searchbox-line" class="form-control hidden" placeholder="Go to line (53, 1120, just type the line number and enter)"><div class="input-group-btn"><div class="btn-group hidden" id="tag-menu"><button data-toggle="dropdown" class="btn btn-default dropdown-toggle" id="tag-default"></button><ul class="dropdown-menu pull-center" id="tag-entries"></ul></div><a class="btn btn-default" href="../meta/about.html" type="button" id="sbexr-about"><i title="About this site" class="glyphicon glyphicon-info-sign"></i></a><a class="btn btn-default" href="../meta/help.html" type="button" id="sbexr-help"><i title="Help!!" class="glyphicon glyphicon-question-sign"></i></a></div></div></div></div><!-- /.navbar-collapse --></div><!-- /.container-fluid --></nav></div><pre class='code'><span id='line-number'><i>1</i><i>2</i><i>3</i><i>4</i><i>5</i><i>6</i><i>7</i><i>8</i><i>9</i><i>10</i><i>11</i><i>12</i><i>13</i><i>14</i><i>15</i><i>16</i><i>17</i><i>18</i><i>19</i><i>20</i><i>21</i><i>22</i><i>23</i><i>24</i><i>25</i><i>26</i><i>27</i><i>28</i><i>29</i><i>30</i><i>31</i><i>32</i><i>33</i><i>34</i><i>35</i><i>36</i><i>37</i><i>38</i><i>39</i><i>40</i><i>41</i><i>42</i><i>43</i><i>44</i><i>45</i><i>46</i><i>47</i><i>48</i><i>49</i><i>50</i><i>51</i><i>52</i><i>53</i><i>54</i><i>55</i><i>56</i><i>57</i><i>58</i><i>59</i><i>60</i><i>61</i><i>62</i><i>63</i><i>64</i><i>65</i><i>66</i><i>67</i><i>68</i><i>69</i><i>70</i><i>71</i><i>72</i><i>73</i><i>74</i><i>75</i><i>76</i><i>77</i><i>78</i><i>79</i><i>80</i><i>81</i><i>82</i><i>83</i><i>84</i><i>85</i><i>86</i><i>87</i><i>88</i><i>89</i><i>90</i><i>91</i><i>92</i><i>93</i><i>94</i><i>95</i><i>96</i><i>97</i><i>98</i><i>99</i><i>100</i><i>101</i><i>102</i><i>103</i><i>104</i><i>105</i><i>106</i><i>107</i><i>108</i><i>109</i><i>110</i><i>111</i><i>112</i><i>113</i><i>114</i><i>115</i><i>116</i><i>117</i><i>118</i><i>119</i><i>120</i><i>121</i><i>122</i><i>123</i><i>124</i><i>125</i><i>126</i><i>127</i><i>128</i><i>129</i><i>130</i><i>131</i><i>132</i><i>133</i><i>134</i><i>135</i><i>136</i><i>137</i><i>138</i><i>139</i><i>140</i><i>141</i><i>142</i><i>143</i><i>144</i><i>145</i><i>146</i><i>147</i><i>148</i><i>149</i><i>150</i><i>151</i><i>152</i><i>153</i><i>154</i><i>155</i><i>156</i><i>157</i><i>158</i><i>159</i><i>160</i><i>161</i><i>162</i><i>163</i><i>164</i><i>165</i><i>166</i><i>167</i><i>168</i><i>169</i><i>170</i><i>171</i><i>172</i><i>173</i><i>174</i><i>175</i><i>176</i><i>177</i><i>178</i><i>179</i><i>180</i><i>181</i><i>182</i><i>183</i><i>184</i><i>185</i><i>186</i><i>187</i><i>188</i><i>189</i><i>190</i><i>191</i><i>192</i><i>193</i><i>194</i><i>195</i><i>196</i><i>197</i><i>198</i><i>199</i><i>200</i><i>201</i><i>202</i><i>203</i><i>204</i><i>205</i><i>206</i><i>207</i><i>208</i><i>209</i><i>210</i><i>211</i><i>212</i><i>213</i><i>214</i><i>215</i><i>216</i><i>217</i><i>218</i><i>219</i><i>220</i><i>221</i><i>222</i><i>223</i><i>224</i><i>225</i><i>226</i><i>227</i><i>228</i><i>229</i><i>230</i><i>231</i><i>232</i><i>233</i><i>234</i><i>235</i><i>236</i><i>237</i><i>238</i><i>239</i><i>240</i><i>241</i><i>242</i><i>243</i><i>244</i><i>245</i><i>246</i><i>247</i><i>248</i><i>249</i><i>250</i><i>251</i><i>252</i><i>253</i><i>254</i><i>255</i><i>256</i><i>257</i><i>258</i><i>259</i><i>260</i><i>261</i><i>262</i><i>263</i><i>264</i><i>265</i><i>266</i><i>267</i><i>268</i><i>269</i><i>270</i><i>271</i><i>272</i><i>273</i><i>274</i><i>275</i><i>276</i><i>277</i><i>278</i><i>279</i><i>280</i><i>281</i><i>282</i><i>283</i><i>284</i><i>285</i><i>286</i><i>287</i><i>288</i><i>289</i><i>290</i><i>291</i><i>292</i><i>293</i><i>294</i><i>295</i><i>296</i><i>297</i><i>298</i><i>299</i><i>300</i><i>301</i><i>302</i><i>303</i><i>304</i><i>305</i><i>306</i><i>307</i><i>308</i><i>309</i><i>310</i><i>311</i><i>312</i><i>313</i><i>314</i><i>315</i><i>316</i><i>317</i><i>318</i><i>319</i><i>320</i><i>321</i><i>322</i><i>323</i><i>324</i><i>325</i><i>326</i><i>327</i><i>328</i><i>329</i><i>330</i><i>331</i><i>332</i><i>333</i><i>334</i><i>335</i><i>336</i><i>337</i><i>338</i><i>339</i><i>340</i><i>341</i><i>342</i><i>343</i><i>344</i><i>345</i><i>346</i><i>347</i><i>348</i><i>349</i><i>350</i><i>351</i><i>352</i><i>353</i><i>354</i><i>355</i><i>356</i><i>357</i><i>358</i><i>359</i><i>360</i><i>361</i><i>362</i><i>363</i><i>364</i><i>365</i><i>366</i><i>367</i><i>368</i><i>369</i><i>370</i><i>371</i><i>372</i><i>373</i><i>374</i><i>375</i><i>376</i><i>377</i><i>378</i><i>379</i><i>380</i><i>381</i><i>382</i><i>383</i><i>384</i><i>385</i><i>386</i><i>387</i><i>388</i><i>389</i><i>390</i><i>391</i><i>392</i><i>393</i><i>394</i><i>395</i><i>396</i><i>397</i><i>398</i><i>399</i><i>400</i><i>401</i><i>402</i><i>403</i><i>404</i><i>405</i><i>406</i><i>407</i><i>408</i><i>409</i><i>410</i><i>411</i><i>412</i><i>413</i><i>414</i><i>415</i><i>416</i><i>417</i><i>418</i><i>419</i><i>420</i><i>421</i><i>422</i><i>423</i><i>424</i><i>425</i><i>426</i><i>427</i><i>428</i><i>429</i><i>430</i><i>431</i><i>432</i><i>433</i><i>434</i><i>435</i><i>436</i><i>437</i><i>438</i><i>439</i><i>440</i><i>441</i><i>442</i><i>443</i><i>444</i><i>445</i><i>446</i><i>447</i><i>448</i><i>449</i><i>450</i><i>451</i><i>452</i><i>453</i><i>454</i><i>455</i><i>456</i><i>457</i><i>458</i><i>459</i><i>460</i><i>461</i><i>462</i><i>463</i><i>464</i><i>465</i><i>466</i><i>467</i><i>468</i><i>469</i><i>470</i><i>471</i><i>472</i><i>473</i><i>474</i><i>475</i><i>476</i><i>477</i><i>478</i><i>479</i><i>480</i><i>481</i><i>482</i><i>483</i><i>484</i><i>485</i><i>486</i><i>487</i><i>488</i><i>489</i><i>490</i><i>491</i><i>492</i><i>493</i><i>494</i><i>495</i><i>496</i><i>497</i><i>498</i><i>499</i><i>500</i><i>501</i><i>502</i><i>503</i><i>504</i><i>505</i><i>506</i><i>507</i><i>508</i><i>509</i><i>510</i><i>511</i><i>512</i><i>513</i><i>514</i><i>515</i><i>516</i><i>517</i><i>518</i><i>519</i><i>520</i><i>521</i><i>522</i><i>523</i><i>524</i><i>525</i><i>526</i><i>527</i><i>528</i><i>529</i><i>530</i><i>531</i><i>532</i><i>533</i><i>534</i><i>535</i><i>536</i><i>537</i><i>538</i><i>539</i><i>540</i><i>541</i><i>542</i><i>543</i><i>544</i><i>545</i><i>546</i><i>547</i><i>548</i><i>549</i><i>550</i><i>551</i><i>552</i><i>553</i><i>554</i><i>555</i><i>556</i><i>557</i><i>558</i><i>559</i><i>560</i><i>561</i><i>562</i><i>563</i><i>564</i><i>565</i><i>566</i><i>567</i><i>568</i><i>569</i><i>570</i><i>571</i><i>572</i><i>573</i><i>574</i><i>575</i><i>576</i><i>577</i><i>578</i><i>579</i><i>580</i><i>581</i><i>582</i><i>583</i><i>584</i><i>585</i><i>586</i><i>587</i><i>588</i><i>589</i><i>590</i><i>591</i><i>592</i><i>593</i><i>594</i><i>595</i><i>596</i><i>597</i><i>598</i><i>599</i><i>600</i><i>601</i><i>602</i><i>603</i><i>604</i><i>605</i><i>606</i><i>607</i><i>608</i><i>609</i><i>610</i><i>611</i><i>612</i><i>613</i><i>614</i><i>615</i><i>616</i><i>617</i><i>618</i><i>619</i><i>620</i><i>621</i><i>622</i><i>623</i><i>624</i><i>625</i><i>626</i><i>627</i><i>628</i><i>629</i><i>630</i><i>631</i><i>632</i><i>633</i><i>634</i><i>635</i><i>636</i><i>637</i><i>638</i><i>639</i><i>640</i><i>641</i><i>642</i><i>643</i><i>644</i><i>645</i><i>646</i><i>647</i><i>648</i><i>649</i><i>650</i><i>651</i><i>652</i><i>653</i><i>654</i><i>655</i><i>656</i><i>657</i><i>658</i><i>659</i><i>660</i><i>661</i><i>662</i><i>663</i><i>664</i><i>665</i><i>666</i><i>667</i><i>668</i><i>669</i><i>670</i><i>671</i><i>672</i><i>673</i><i>674</i><i>675</i><i>676</i><i>677</i><i>678</i><i>679</i><i>680</i><i>681</i><i>682</i><i>683</i><i>684</i><i>685</i><i>686</i><i>687</i><i>688</i><i>689</i><i>690</i><i>691</i><i>692</i><i>693</i><i>694</i><i>695</i><i>696</i><i>697</i><i>698</i><i>699</i><i>700</i><i>701</i><i>702</i><i>703</i><i>704</i><i>705</i><i>706</i><i>707</i><i>708</i><i>709</i><i>710</i><i>711</i><i>712</i><i>713</i><i>714</i><i>715</i><i>716</i><i>717</i><i>718</i><i>719</i><i>720</i><i>721</i><i>722</i><i>723</i><i>724</i><i>725</i><i>726</i><i>727</i><i>728</i><i>729</i><i>730</i><i>731</i><i>732</i><i>733</i><i>734</i><i>735</i><i>736</i><i>737</i><i>738</i><i>739</i><i>740</i><i>741</i><i>742</i><i>743</i><i>744</i><i>745</i><i>746</i><i>747</i><i>748</i><i>749</i><i>750</i><i>751</i><i>752</i><i>753</i><i>754</i><i>755</i><i>756</i><i>757</i><i>758</i><i>759</i><i>760</i><i>761</i><i>762</i><i>763</i><i>764</i><i>765</i><i>766</i><i>767</i><i>768</i><i>769</i><i>770</i><i>771</i><i>772</i><i>773</i><i>774</i><i>775</i><i>776</i><i>777</i><i>778</i><i>779</i><i>780</i><i>781</i><i>782</i><i>783</i><i>784</i><i>785</i><i>786</i><i>787</i><i>788</i><i>789</i><i>790</i><i>791</i><i>792</i><i>793</i><i>794</i><i>795</i><i>796</i><i>797</i><i>798</i><i>799</i><i>800</i><i>801</i><i>802</i><i>803</i><i>804</i><i>805</i><i>806</i><i>807</i><i>808</i><i>809</i><i>810</i><i>811</i><i>812</i><i>813</i><i>814</i><i>815</i><i>816</i><i>817</i><i>818</i><i>819</i><i>820</i><i>821</i><i>822</i><i>823</i><i>824</i><i>825</i><i>826</i><i>827</i><i>828</i><i>829</i><i>830</i><i>831</i><i>832</i><i>833</i><i>834</i><i>835</i><i>836</i><i>837</i><i>838</i><i>839</i><i>840</i><i>841</i><i>842</i><i>843</i><i>844</i><i>845</i><i>846</i><i>847</i><i>848</i><i>849</i><i>850</i><i>851</i><i>852</i><i>853</i><i>854</i><i>855</i><i>856</i><i>857</i><i>858</i><i>859</i><i>860</i><i>861</i><i>862</i><i>863</i><i>864</i><i>865</i><i>866</i><i>867</i><i>868</i><i>869</i><i>870</i><i>871</i><i>872</i><i>873</i><i>874</i><i>875</i><i>876</i><i>877</i><i>878</i><i>879</i><i>880</i><i>881</i><i>882</i><i>883</i><i>884</i><i>885</i><i>886</i><i>887</i><i>888</i><i>889</i><i>890</i><i>891</i><i>892</i><i>893</i><i>894</i><i>895</i><i>896</i><i>897</i><i>898</i><i>899</i><i>900</i><i>901</i><i>902</i><i>903</i></span><span itemscope itemtype="http://schema.org/SoftwareSourceCode"><meta itemprop="programmingLanguage" content="C" /><span class='comment'>/* Copyright (C) 1995-2016 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, see
   &lt;http://www.gnu.org/licenses/&gt;.  */</span>

<span class='comment'>/*
 *      ISO C99 Standard: 7.24
 *	Extended multibyte and wide character utilities	&lt;wchar.h&gt;
 */</span>

<span class='directive'>#ifndef _WCHAR_H</span>

<span class='directive'>#if !defined __need_mbstate_t &amp;&amp; !defined __need_wint_t</span><span class='preprocessor-if muted'>
<span class='directive'># define _WCHAR_H 1</span>
<span class='directive'># include &lt;features.h&gt;</span></span>
<span class='directive'>#endif</span>

<span class='directive'>#ifdef _WCHAR_H</span><span class='preprocessor-if muted'>
<span class='comment'>/* Get FILE definition.  */</span>
<span class='directive'># define __need___FILE</span>
<span class='directive'># if defined __USE_UNIX98 || defined __USE_XOPEN2K</span>
<span class='directive'>#  define __need_FILE</span>
<span class='directive'># endif</span>
<span class='directive'># include &lt;stdio.h&gt;</span>
<span class='comment'>/* Get va_list definition.  */</span>
<span class='directive'># define __need___va_list</span>
<span class='directive'># include &lt;stdarg.h&gt;</span>

<span class='directive'># include &lt;bits/wchar.h&gt;</span>

<span class='comment'>/* Get size_t, wchar_t, wint_t and NULL from &lt;stddef.h&gt;.  */</span>
<span class='directive'># define __need_size_t</span>
<span class='directive'># define __need_wchar_t</span>
<span class='directive'># define __need_NULL</span></span>
<span class='directive'>#endif</span>
<span class='directive'>#if defined _WCHAR_H || defined __need_wint_t || !defined __WINT_TYPE__</span><span class='preprocessor-if muted'>
<span class='directive'># undef __need_wint_t</span>
<span class='directive'># define __need_wint_t</span>
<span class='directive'># include &lt;stddef.h&gt;</span>

<span class='comment'>/* We try to get wint_t from &lt;stddef.h&gt;, but not all GCC versions define it
   there.  So define it ourselves if it remains undefined.  */</span>
<span class='directive'># ifndef _WINT_T</span>
<span class='comment'>/* Integral type unchanged by default argument promotions that can
   hold any value corresponding to members of the extended character
   set, as well as at least one value that does not correspond to any
   member of the extended character set.  */</span>
<span class='directive'>#  define _WINT_T</span>
<span class='keyword typedef'>typedef</span> <span class='keyword unsigned'>unsigned</span> <span class='keyword int'>int</span> wint_t;
<span class='directive'># else</span>
<span class='comment'>/* Work around problems with the &lt;stddef.h&gt; file which doesn't put
   wint_t in the std namespace.  */</span>
<span class='directive'>#  if defined __cplusplus &amp;&amp; defined _GLIBCPP_USE_NAMESPACES \
      &amp;&amp; defined __WINT_TYPE__</span>
__BEGIN_NAMESPACE_STD
<span class='keyword typedef'>typedef</span> __WINT_TYPE__ wint_t;
__END_NAMESPACE_STD
<span class='directive'>#  endif</span>
<span class='directive'># endif</span>

<span class='comment'>/* Tell the caller that we provide correct C++ prototypes.  */</span>
<span class='directive'># if defined __cplusplus &amp;&amp; __GNUC_PREREQ (4, 4)</span>
<span class='directive'>#  define __CORRECT_ISO_CPP_WCHAR_H_PROTO</span>
<span class='directive'># endif</span></span>
<span class='directive'>#endif</span>

<span class='directive'>#if (defined _WCHAR_H || defined __need_mbstate_t) &amp;&amp; !defined ____mbstate_t_defined</span>
<span class='directive'># define ____mbstate_t_defined	1</span>
<span class='comment'>/* Conversion state information.  */</span>
<span class='def def-Typedef' id='000520010005e003'><span class='keyword typedef'>typedef</span> <span class='def def-CXXRecord' id='000520090005e001'><span class='keyword struct'>struct</span>
{
  <span class='def def-Field' id='0005400300054007'><span class='keyword int'>int</span> __count</span>;
  <span class='def def-Field' id='000550030005d005'><span class='def def-CXXRecord' id='000550030005d003'><a class='declaration-uses' href='../36/d105d6d6487cc5.html#000550030005d003'><span class='keyword union'>union</span></a>
  {
<span class='directive'># ifdef __WINT_TYPE__</span>
    <span class='def def-Field' id='0006b017000580130005800500058013'>__WINT_TYPE__ __wch</span>;
<span class='directive'># else</span><span class='preprocessor-if muted'>
    wint_t __wch;</span>
<span class='directive'># endif</span>
    <span class='def def-Field' id='0005c0050005c012'><span class='keyword char'>char</span> __wchb[<span class='numeric'>4</span>]</span>;
  }</span> __value</span>;		<span class='comment'>/* Value so far.  */</span>
}</span> __mbstate_t</span>;
<span class='directive'>#endif</span>
<span class='directive'>#undef __need_mbstate_t</span>


<span class='comment'>/* The rest of the file is only used if used if __need_mbstate_t is not
   defined.  */</span>
<span class='directive'>#ifdef _WCHAR_H</span><span class='preprocessor-if muted'>

<span class='directive'># ifndef __mbstate_t_defined</span>
__BEGIN_NAMESPACE_C99
<span class='comment'>/* Public type.  */</span>
<span class='keyword typedef'>typedef</span> __mbstate_t mbstate_t;
__END_NAMESPACE_C99
<span class='directive'>#  define __mbstate_t_defined 1</span>
<span class='directive'># endif</span>

<span class='directive'>#ifdef __USE_GNU</span>
__USING_NAMESPACE_C99(mbstate_t)
<span class='directive'>#endif</span>

<span class='directive'>#ifndef WCHAR_MIN</span>
<span class='comment'>/* These constants might also be defined in &lt;inttypes.h&gt;.  */</span>
<span class='directive'># define WCHAR_MIN __WCHAR_MIN</span>
<span class='directive'># define WCHAR_MAX __WCHAR_MAX</span>
<span class='directive'>#endif</span>

<span class='directive'>#ifndef WEOF</span>
<span class='directive'># define WEOF (0xffffffffu)</span>
<span class='directive'>#endif</span>

<span class='comment'>/* For XPG4 compliance we have to define the stuff from &lt;wctype.h&gt; here
   as well.  */</span>
<span class='directive'>#if defined __USE_XOPEN &amp;&amp; !defined __USE_UNIX98</span>
<span class='directive'># include &lt;wctype.h&gt;</span>
<span class='directive'>#endif</span>


__BEGIN_DECLS

__BEGIN_NAMESPACE_STD
<span class='comment'>/* This incomplete type is defined in &lt;time.h&gt; but needed here because
   of `wcsftime'.  */</span>
<span class='keyword struct'>struct</span> tm;
__END_NAMESPACE_STD
<span class='comment'>/* XXX We have to clean this up at some point.  Since tm is in the std
   namespace but wcsftime is in __c99 the type wouldn't be found
   without inserting it in the global namespace.  */</span>
__USING_NAMESPACE_STD(tm)


__BEGIN_NAMESPACE_STD
<span class='comment'>/* Copy SRC to DEST.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wcscpy (<span class='keyword wchar_t'>wchar_t</span> *__restrict __dest,
			<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __src)
     __THROW __nonnull ((<span class='numeric'>1</span>, <span class='numeric'>2</span>));

<span class='comment'>/* Copy no more than N wide-characters of SRC to DEST.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wcsncpy (<span class='keyword wchar_t'>wchar_t</span> *__restrict __dest,
			 <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __src, size_t __n)
     __THROW __nonnull ((<span class='numeric'>1</span>, <span class='numeric'>2</span>));

<span class='comment'>/* Append SRC onto DEST.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wcscat (<span class='keyword wchar_t'>wchar_t</span> *__restrict __dest,
			<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __src)
     __THROW __nonnull ((<span class='numeric'>1</span>, <span class='numeric'>2</span>));
<span class='comment'>/* Append no more than N wide-characters of SRC onto DEST.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wcsncat (<span class='keyword wchar_t'>wchar_t</span> *__restrict __dest,
			 <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __src, size_t __n)
     __THROW __nonnull ((<span class='numeric'>1</span>, <span class='numeric'>2</span>));

<span class='comment'>/* Compare S1 and S2.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> wcscmp (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s1, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s2)
     __THROW __attribute_pure__ __nonnull ((<span class='numeric'>1</span>, <span class='numeric'>2</span>));
<span class='comment'>/* Compare N wide-characters of S1 and S2.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> wcsncmp (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s1, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s2, size_t __n)
     __THROW __attribute_pure__ __nonnull ((<span class='numeric'>1</span>, <span class='numeric'>2</span>));
__END_NAMESPACE_STD

<span class='directive'>#ifdef __USE_XOPEN2K8</span>
<span class='comment'>/* Compare S1 and S2, ignoring case.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> wcscasecmp (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s1, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s2) __THROW;

<span class='comment'>/* Compare no more than N chars of S1 and S2, ignoring case.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> wcsncasecmp (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s1, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s2,
			size_t __n) __THROW;

<span class='comment'>/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */</span>
<span class='directive'># include &lt;xlocale.h&gt;</span>

<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> wcscasecmp_l (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s1, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s2,
			 __locale_t __loc) __THROW;

<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> wcsncasecmp_l (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s1, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s2,
			  size_t __n, __locale_t __loc) __THROW;
<span class='directive'>#endif</span>

__BEGIN_NAMESPACE_STD
<span class='comment'>/* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the current locale.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> wcscoll (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s1, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s2) __THROW;
<span class='comment'>/* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  */</span>
<span class='keyword extern'>extern</span> size_t wcsxfrm (<span class='keyword wchar_t'>wchar_t</span> *__restrict __s1,
		       <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __s2, size_t __n) __THROW;
__END_NAMESPACE_STD

<span class='directive'>#ifdef __USE_XOPEN2K8</span>
<span class='comment'>/* Similar to the two functions above but take the information from
   the provided locale and not the global locale.  */</span>

<span class='comment'>/* Compare S1 and S2, both interpreted as appropriate to the
   LC_COLLATE category of the given locale.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> wcscoll_l (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s1, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s2,
		      __locale_t __loc) __THROW;

<span class='comment'>/* Transform S2 into array pointed to by S1 such that if wcscmp is
   applied to two transformed strings the result is the as applying
   `wcscoll' to the original strings.  */</span>
<span class='keyword extern'>extern</span> size_t wcsxfrm_l (<span class='keyword wchar_t'>wchar_t</span> *__s1, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s2,
			 size_t __n, __locale_t __loc) __THROW;

<span class='comment'>/* Duplicate S, returning an identical malloc'd string.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wcsdup (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s) __THROW __attribute_malloc__;
<span class='directive'>#endif</span>

__BEGIN_NAMESPACE_STD
<span class='comment'>/* Find the first occurrence of WC in WCS.  */</span>
<span class='directive'>#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO</span>
<span class='keyword extern'>extern</span> <span class='string'>"C++"</span> <span class='keyword wchar_t'>wchar_t</span> *wcschr (<span class='keyword wchar_t'>wchar_t</span> *__wcs, <span class='keyword wchar_t'>wchar_t</span> __wc)
     __THROW <span class='keyword __asm'>__asm</span> (<span class='string'>"wcschr"</span>) __attribute_pure__;
<span class='keyword extern'>extern</span> <span class='string'>"C++"</span> <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *wcschr (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__wcs, <span class='keyword wchar_t'>wchar_t</span> __wc)
     __THROW <span class='keyword __asm'>__asm</span> (<span class='string'>"wcschr"</span>) __attribute_pure__;
<span class='directive'>#else</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wcschr (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__wcs, <span class='keyword wchar_t'>wchar_t</span> __wc)
     __THROW __attribute_pure__;
<span class='directive'>#endif</span>
<span class='comment'>/* Find the last occurrence of WC in WCS.  */</span>
<span class='directive'>#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO</span>
<span class='keyword extern'>extern</span> <span class='string'>"C++"</span> <span class='keyword wchar_t'>wchar_t</span> *wcsrchr (<span class='keyword wchar_t'>wchar_t</span> *__wcs, <span class='keyword wchar_t'>wchar_t</span> __wc)
     __THROW <span class='keyword __asm'>__asm</span> (<span class='string'>"wcsrchr"</span>) __attribute_pure__;
<span class='keyword extern'>extern</span> <span class='string'>"C++"</span> <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *wcsrchr (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__wcs, <span class='keyword wchar_t'>wchar_t</span> __wc)
     __THROW <span class='keyword __asm'>__asm</span> (<span class='string'>"wcsrchr"</span>) __attribute_pure__;
<span class='directive'>#else</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wcsrchr (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__wcs, <span class='keyword wchar_t'>wchar_t</span> __wc)
     __THROW __attribute_pure__;
<span class='directive'>#endif</span>
__END_NAMESPACE_STD

<span class='directive'>#ifdef __USE_GNU</span>
<span class='comment'>/* This function is similar to `wcschr'.  But it returns a pointer to
   the closing NUL wide character in case C is not found in S.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wcschrnul (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s, <span class='keyword wchar_t'>wchar_t</span> __wc)
     __THROW __attribute_pure__;
<span class='directive'>#endif</span>

__BEGIN_NAMESPACE_STD
<span class='comment'>/* Return the length of the initial segmet of WCS which
   consists entirely of wide characters not in REJECT.  */</span>
<span class='keyword extern'>extern</span> size_t wcscspn (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__wcs, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__reject)
     __THROW __attribute_pure__;
<span class='comment'>/* Return the length of the initial segmet of WCS which
   consists entirely of wide characters in  ACCEPT.  */</span>
<span class='keyword extern'>extern</span> size_t wcsspn (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__wcs, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__accept)
     __THROW __attribute_pure__;
<span class='comment'>/* Find the first occurrence in WCS of any character in ACCEPT.  */</span>
<span class='directive'>#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO</span>
<span class='keyword extern'>extern</span> <span class='string'>"C++"</span> <span class='keyword wchar_t'>wchar_t</span> *wcspbrk (<span class='keyword wchar_t'>wchar_t</span> *__wcs, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__accept)
     __THROW <span class='keyword __asm'>__asm</span> (<span class='string'>"wcspbrk"</span>) __attribute_pure__;
<span class='keyword extern'>extern</span> <span class='string'>"C++"</span> <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *wcspbrk (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__wcs,
				     <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__accept)
     __THROW <span class='keyword __asm'>__asm</span> (<span class='string'>"wcspbrk"</span>) __attribute_pure__;
<span class='directive'>#else</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wcspbrk (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__wcs, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__accept)
     __THROW __attribute_pure__;
<span class='directive'>#endif</span>
<span class='comment'>/* Find the first occurrence of NEEDLE in HAYSTACK.  */</span>
<span class='directive'>#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO</span>
<span class='keyword extern'>extern</span> <span class='string'>"C++"</span> <span class='keyword wchar_t'>wchar_t</span> *wcsstr (<span class='keyword wchar_t'>wchar_t</span> *__haystack, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__needle)
     __THROW <span class='keyword __asm'>__asm</span> (<span class='string'>"wcsstr"</span>) __attribute_pure__;
<span class='keyword extern'>extern</span> <span class='string'>"C++"</span> <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *wcsstr (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__haystack,
				    <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__needle)
     __THROW <span class='keyword __asm'>__asm</span> (<span class='string'>"wcsstr"</span>) __attribute_pure__;
<span class='directive'>#else</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wcsstr (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__haystack, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__needle)
     __THROW __attribute_pure__;
<span class='directive'>#endif</span>

<span class='comment'>/* Divide WCS into tokens separated by characters in DELIM.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wcstok (<span class='keyword wchar_t'>wchar_t</span> *__restrict __s,
			<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __delim,
			<span class='keyword wchar_t'>wchar_t</span> **__restrict __ptr) __THROW;

<span class='comment'>/* Return the number of wide characters in S.  */</span>
<span class='keyword extern'>extern</span> size_t wcslen (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s) __THROW __attribute_pure__;
__END_NAMESPACE_STD

<span class='directive'>#ifdef __USE_XOPEN</span>
<span class='comment'>/* Another name for `wcsstr' from XPG4.  */</span>
<span class='directive'># ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO</span>
<span class='keyword extern'>extern</span> <span class='string'>"C++"</span> <span class='keyword wchar_t'>wchar_t</span> *wcswcs (<span class='keyword wchar_t'>wchar_t</span> *__haystack, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__needle)
     __THROW <span class='keyword __asm'>__asm</span> (<span class='string'>"wcswcs"</span>) __attribute_pure__;
<span class='keyword extern'>extern</span> <span class='string'>"C++"</span> <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *wcswcs (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__haystack,
				    <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__needle)
     __THROW <span class='keyword __asm'>__asm</span> (<span class='string'>"wcswcs"</span>) __attribute_pure__;
<span class='directive'># else</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wcswcs (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__haystack, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__needle)
     __THROW __attribute_pure__;
<span class='directive'># endif</span>
<span class='directive'>#endif</span>

<span class='directive'>#ifdef __USE_XOPEN2K8</span>
<span class='comment'>/* Return the number of wide characters in S, but at most MAXLEN.  */</span>
<span class='keyword extern'>extern</span> size_t wcsnlen (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s, size_t __maxlen)
     __THROW __attribute_pure__;
<span class='directive'>#endif</span>


__BEGIN_NAMESPACE_STD
<span class='comment'>/* Search N wide characters of S for C.  */</span>
<span class='directive'>#ifdef __CORRECT_ISO_CPP_WCHAR_H_PROTO</span>
<span class='keyword extern'>extern</span> <span class='string'>"C++"</span> <span class='keyword wchar_t'>wchar_t</span> *wmemchr (<span class='keyword wchar_t'>wchar_t</span> *__s, <span class='keyword wchar_t'>wchar_t</span> __c, size_t __n)
     __THROW <span class='keyword __asm'>__asm</span> (<span class='string'>"wmemchr"</span>) __attribute_pure__;
<span class='keyword extern'>extern</span> <span class='string'>"C++"</span> <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *wmemchr (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s, <span class='keyword wchar_t'>wchar_t</span> __c,
				     size_t __n)
     __THROW <span class='keyword __asm'>__asm</span> (<span class='string'>"wmemchr"</span>) __attribute_pure__;
<span class='directive'>#else</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wmemchr (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s, <span class='keyword wchar_t'>wchar_t</span> __c, size_t __n)
     __THROW __attribute_pure__;
<span class='directive'>#endif</span>

<span class='comment'>/* Compare N wide characters of S1 and S2.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> wmemcmp (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s1, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s2, size_t __n)
     __THROW __attribute_pure__;

<span class='comment'>/* Copy N wide characters of SRC to DEST.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wmemcpy (<span class='keyword wchar_t'>wchar_t</span> *__restrict __s1,
			 <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __s2, size_t __n) __THROW;

<span class='comment'>/* Copy N wide characters of SRC to DEST, guaranteeing
   correct behavior for overlapping strings.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wmemmove (<span class='keyword wchar_t'>wchar_t</span> *__s1, <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s2, size_t __n)
     __THROW;

<span class='comment'>/* Set N wide characters of S to C.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wmemset (<span class='keyword wchar_t'>wchar_t</span> *__s, <span class='keyword wchar_t'>wchar_t</span> __c, size_t __n) __THROW;
__END_NAMESPACE_STD

<span class='directive'>#ifdef __USE_GNU</span>
<span class='comment'>/* Copy N wide characters of SRC to DEST and return pointer to following
   wide character.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wmempcpy (<span class='keyword wchar_t'>wchar_t</span> *__restrict __s1,
			  <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __s2, size_t __n)
     __THROW;
<span class='directive'>#endif</span>


__BEGIN_NAMESPACE_STD
<span class='comment'>/* Determine whether C constitutes a valid (one-byte) multibyte
   character.  */</span>
<span class='keyword extern'>extern</span> wint_t btowc (<span class='keyword int'>int</span> __c) __THROW;

<span class='comment'>/* Determine whether C corresponds to a member of the extended
   character set whose multibyte representation is a single byte.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> wctob (wint_t __c) __THROW;

<span class='comment'>/* Determine whether PS points to an object representing the initial
   state.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> mbsinit (<span class='keyword const'>const</span> mbstate_t *__ps) __THROW __attribute_pure__;

<span class='comment'>/* Write wide character representation of multibyte character pointed
   to by S to PWC.  */</span>
<span class='keyword extern'>extern</span> size_t mbrtowc (<span class='keyword wchar_t'>wchar_t</span> *__restrict __pwc,
		       <span class='keyword const'>const</span> <span class='keyword char'>char</span> *__restrict __s, size_t __n,
		       mbstate_t *__restrict __p) __THROW;

<span class='comment'>/* Write multibyte representation of wide character WC to S.  */</span>
<span class='keyword extern'>extern</span> size_t wcrtomb (<span class='keyword char'>char</span> *__restrict __s, <span class='keyword wchar_t'>wchar_t</span> __wc,
		       mbstate_t *__restrict __ps) __THROW;

<span class='comment'>/* Return number of bytes in multibyte character pointed to by S.  */</span>
<span class='keyword extern'>extern</span> size_t __mbrlen (<span class='keyword const'>const</span> <span class='keyword char'>char</span> *__restrict __s, size_t __n,
			mbstate_t *__restrict __ps) __THROW;
<span class='keyword extern'>extern</span> size_t mbrlen (<span class='keyword const'>const</span> <span class='keyword char'>char</span> *__restrict __s, size_t __n,
		      mbstate_t *__restrict __ps) __THROW;
__END_NAMESPACE_STD

<span class='directive'>#ifdef __USE_EXTERN_INLINES</span>
<span class='comment'>/* Define inline function as optimization.  */</span>

<span class='comment'>/* We can use the BTOWC and WCTOB optimizations since we know that all
   locales must use ASCII encoding for the values in the ASCII range
   and because the wchar_t encoding is always ISO 10646.  */</span>
<span class='keyword extern'>extern</span> wint_t __btowc_alias (<span class='keyword int'>int</span> __c) <span class='keyword __asm'>__asm</span> (<span class='string'>"btowc"</span>);
__extern_inline wint_t
__NTH (btowc (<span class='keyword int'>int</span> __c))
{ <span class='keyword return'>return</span> (__builtin_constant_p (__c) &amp;&amp; __c &gt;= <span class='char'>'\0'</span> &amp;&amp; __c &lt;= <span class='char'>'\x7f'</span>
	  ? (wint_t) __c : __btowc_alias (__c)); }

<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> __wctob_alias (wint_t __c) <span class='keyword __asm'>__asm</span> (<span class='string'>"wctob"</span>);
__extern_inline <span class='keyword int'>int</span>
__NTH (wctob (wint_t __wc))
{ <span class='keyword return'>return</span> (__builtin_constant_p (__wc) &amp;&amp; __wc &gt;= L<span class='char'>'\0'</span> &amp;&amp; __wc &lt;= L<span class='char'>'\x7f'</span>
	  ? (<span class='keyword int'>int</span>) __wc : __wctob_alias (__wc)); }

__extern_inline size_t
__NTH (mbrlen (<span class='keyword const'>const</span> <span class='keyword char'>char</span> *__restrict __s, size_t __n,
	       mbstate_t *__restrict __ps))
{ <span class='keyword return'>return</span> (__ps != NULL
	  ? mbrtowc (NULL, __s, __n, __ps) : __mbrlen (__s, __n, NULL)); }
<span class='directive'>#endif</span>

__BEGIN_NAMESPACE_STD
<span class='comment'>/* Write wide character representation of multibyte character string
   SRC to DST.  */</span>
<span class='keyword extern'>extern</span> size_t mbsrtowcs (<span class='keyword wchar_t'>wchar_t</span> *__restrict __dst,
			 <span class='keyword const'>const</span> <span class='keyword char'>char</span> **__restrict __src, size_t __len,
			 mbstate_t *__restrict __ps) __THROW;

<span class='comment'>/* Write multibyte character representation of wide character string
   SRC to DST.  */</span>
<span class='keyword extern'>extern</span> size_t wcsrtombs (<span class='keyword char'>char</span> *__restrict __dst,
			 <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> **__restrict __src, size_t __len,
			 mbstate_t *__restrict __ps) __THROW;
__END_NAMESPACE_STD


<span class='directive'>#ifdef	__USE_XOPEN2K8</span>
<span class='comment'>/* Write wide character representation of at most NMC bytes of the
   multibyte character string SRC to DST.  */</span>
<span class='keyword extern'>extern</span> size_t mbsnrtowcs (<span class='keyword wchar_t'>wchar_t</span> *__restrict __dst,
			  <span class='keyword const'>const</span> <span class='keyword char'>char</span> **__restrict __src, size_t __nmc,
			  size_t __len, mbstate_t *__restrict __ps) __THROW;

<span class='comment'>/* Write multibyte character representation of at most NWC characters
   from the wide character string SRC to DST.  */</span>
<span class='keyword extern'>extern</span> size_t wcsnrtombs (<span class='keyword char'>char</span> *__restrict __dst,
			  <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> **__restrict __src,
			  size_t __nwc, size_t __len,
			  mbstate_t *__restrict __ps) __THROW;
<span class='directive'>#endif	/* use POSIX 2008 */</span>


<span class='comment'>/* The following functions are extensions found in X/Open CAE.  */</span>
<span class='directive'>#ifdef __USE_XOPEN</span>
<span class='comment'>/* Determine number of column positions required for C.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> wcwidth (<span class='keyword wchar_t'>wchar_t</span> __c) __THROW;

<span class='comment'>/* Determine number of column positions required for first N wide
   characters (or fewer if S ends before this) in S.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> wcswidth (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__s, size_t __n) __THROW;
<span class='directive'>#endif	/* Use X/Open.  */</span>


__BEGIN_NAMESPACE_STD
<span class='comment'>/* Convert initial portion of the wide string NPTR to `double'
   representation.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword double'>double</span> wcstod (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
		      <span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr) __THROW;
__END_NAMESPACE_STD

<span class='directive'>#ifdef __USE_ISOC99</span>
__BEGIN_NAMESPACE_C99
<span class='comment'>/* Likewise for `float' and `long double' sizes of floating-point numbers.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword float'>float</span> wcstof (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
		     <span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr) __THROW;
<span class='keyword extern'>extern</span> <span class='keyword long'>long</span> <span class='keyword double'>double</span> wcstold (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
			    <span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr) __THROW;
__END_NAMESPACE_C99
<span class='directive'>#endif /* C99 */</span>


__BEGIN_NAMESPACE_STD
<span class='comment'>/* Convert initial portion of wide string NPTR to `long int'
   representation.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword long'>long</span> <span class='keyword int'>int</span> wcstol (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
			<span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr, <span class='keyword int'>int</span> __base) __THROW;

<span class='comment'>/* Convert initial portion of wide string NPTR to `unsigned long int'
   representation.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword unsigned'>unsigned</span> <span class='keyword long'>long</span> <span class='keyword int'>int</span> wcstoul (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
				  <span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr, <span class='keyword int'>int</span> __base)
     __THROW;
__END_NAMESPACE_STD

<span class='directive'>#ifdef __USE_ISOC99</span>
__BEGIN_NAMESPACE_C99
<span class='comment'>/* Convert initial portion of wide string NPTR to `long long int'
   representation.  */</span>
<span class='keyword __extension__'>__extension__</span>
<span class='keyword extern'>extern</span> <span class='keyword long'>long</span> <span class='keyword long'>long</span> <span class='keyword int'>int</span> wcstoll (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
			      <span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr, <span class='keyword int'>int</span> __base)
     __THROW;

<span class='comment'>/* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  */</span>
<span class='keyword __extension__'>__extension__</span>
<span class='keyword extern'>extern</span> <span class='keyword unsigned'>unsigned</span> <span class='keyword long'>long</span> <span class='keyword long'>long</span> <span class='keyword int'>int</span> wcstoull (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
					<span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr,
					<span class='keyword int'>int</span> __base) __THROW;
__END_NAMESPACE_C99
<span class='directive'>#endif /* ISO C99.  */</span>

<span class='directive'>#ifdef __USE_GNU</span>
<span class='comment'>/* Convert initial portion of wide string NPTR to `long long int'
   representation.  */</span>
<span class='keyword __extension__'>__extension__</span>
<span class='keyword extern'>extern</span> <span class='keyword long'>long</span> <span class='keyword long'>long</span> <span class='keyword int'>int</span> wcstoq (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
			     <span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr, <span class='keyword int'>int</span> __base)
     __THROW;

<span class='comment'>/* Convert initial portion of wide string NPTR to `unsigned long long int'
   representation.  */</span>
<span class='keyword __extension__'>__extension__</span>
<span class='keyword extern'>extern</span> <span class='keyword unsigned'>unsigned</span> <span class='keyword long'>long</span> <span class='keyword long'>long</span> <span class='keyword int'>int</span> wcstouq (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
				       <span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr,
				       <span class='keyword int'>int</span> __base) __THROW;
<span class='directive'>#endif /* Use GNU.  */</span>

<span class='directive'>#ifdef __USE_GNU</span>
<span class='comment'>/* The concept of one static locale per category is not very well
   thought out.  Many applications will need to process its data using
   information from several different locales.  Another application is
   the implementation of the internationalization handling in the
   upcoming ISO C++ standard library.  To support this another set of
   the functions using locale data exist which have an additional
   argument.

   Attention: all these functions are *not* standardized in any form.
   This is a proof-of-concept implementation.  */</span>

<span class='comment'>/* Structure for reentrant locale using functions.  This is an
   (almost) opaque type for the user level programs.  */</span>
<span class='directive'># include &lt;xlocale.h&gt;</span>

<span class='comment'>/* Special versions of the functions above which take the locale to
   use as an additional parameter.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword long'>long</span> <span class='keyword int'>int</span> wcstol_l (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
			  <span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr, <span class='keyword int'>int</span> __base,
			  __locale_t __loc) __THROW;

<span class='keyword extern'>extern</span> <span class='keyword unsigned'>unsigned</span> <span class='keyword long'>long</span> <span class='keyword int'>int</span> wcstoul_l (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
				    <span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr,
				    <span class='keyword int'>int</span> __base, __locale_t __loc) __THROW;

<span class='keyword __extension__'>__extension__</span>
<span class='keyword extern'>extern</span> <span class='keyword long'>long</span> <span class='keyword long'>long</span> <span class='keyword int'>int</span> wcstoll_l (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
				<span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr,
				<span class='keyword int'>int</span> __base, __locale_t __loc) __THROW;

<span class='keyword __extension__'>__extension__</span>
<span class='keyword extern'>extern</span> <span class='keyword unsigned'>unsigned</span> <span class='keyword long'>long</span> <span class='keyword long'>long</span> <span class='keyword int'>int</span> wcstoull_l (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
					  <span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr,
					  <span class='keyword int'>int</span> __base, __locale_t __loc)
     __THROW;

<span class='keyword extern'>extern</span> <span class='keyword double'>double</span> wcstod_l (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
			<span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr, __locale_t __loc)
     __THROW;

<span class='keyword extern'>extern</span> <span class='keyword float'>float</span> wcstof_l (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
		       <span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr, __locale_t __loc)
     __THROW;

<span class='keyword extern'>extern</span> <span class='keyword long'>long</span> <span class='keyword double'>double</span> wcstold_l (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __nptr,
			      <span class='keyword wchar_t'>wchar_t</span> **__restrict __endptr,
			      __locale_t __loc) __THROW;
<span class='directive'>#endif	/* use GNU */</span>


<span class='directive'>#ifdef __USE_XOPEN2K8</span>
<span class='comment'>/* Copy SRC to DEST, returning the address of the terminating L'\0' in
   DEST.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wcpcpy (<span class='keyword wchar_t'>wchar_t</span> *__restrict __dest,
			<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __src) __THROW;

<span class='comment'>/* Copy no more than N characters of SRC to DEST, returning the address of
   the last character written into DEST.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *wcpncpy (<span class='keyword wchar_t'>wchar_t</span> *__restrict __dest,
			 <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __src, size_t __n)
     __THROW;


<span class='comment'>/* Wide character I/O functions.  */</span>

<span class='comment'>/* Like OPEN_MEMSTREAM, but the stream is wide oriented and produces
   a wide character string.  */</span>
<span class='keyword extern'>extern</span> __FILE *open_wmemstream (<span class='keyword wchar_t'>wchar_t</span> **__bufloc, size_t *__sizeloc) __THROW;
<span class='directive'>#endif</span>

<span class='directive'>#if defined __USE_ISOC95 || defined __USE_UNIX98</span>
__BEGIN_NAMESPACE_STD

<span class='comment'>/* Select orientation for stream.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> fwide (__FILE *__fp, <span class='keyword int'>int</span> __mode) __THROW;


<span class='comment'>/* Write formatted output to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> fwprintf (__FILE *__restrict __stream,
		     <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format, ...)
     <span class='comment'>/* __attribute__ ((__format__ (__wprintf__, 2, 3))) */</span>;
<span class='comment'>/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> wprintf (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format, ...)
     <span class='comment'>/* __attribute__ ((__format__ (__wprintf__, 1, 2))) */</span>;
<span class='comment'>/* Write formatted output of at most N characters to S.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> swprintf (<span class='keyword wchar_t'>wchar_t</span> *__restrict __s, size_t __n,
		     <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format, ...)
     __THROW <span class='comment'>/* __attribute__ ((__format__ (__wprintf__, 3, 4))) */</span>;

<span class='comment'>/* Write formatted output to S from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> vfwprintf (__FILE *__restrict __s,
		      <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
		      __gnuc_va_list __arg)
     <span class='comment'>/* __attribute__ ((__format__ (__wprintf__, 2, 0))) */</span>;
<span class='comment'>/* Write formatted output to stdout from argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> vwprintf (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
		     __gnuc_va_list __arg)
     <span class='comment'>/* __attribute__ ((__format__ (__wprintf__, 1, 0))) */</span>;
<span class='comment'>/* Write formatted output of at most N character to S from argument
   list ARG.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> vswprintf (<span class='keyword wchar_t'>wchar_t</span> *__restrict __s, size_t __n,
		      <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
		      __gnuc_va_list __arg)
     __THROW <span class='comment'>/* __attribute__ ((__format__ (__wprintf__, 3, 0))) */</span>;


<span class='comment'>/* Read formatted input from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> fwscanf (__FILE *__restrict __stream,
		    <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format, ...)
     <span class='comment'>/* __attribute__ ((__format__ (__wscanf__, 2, 3))) */</span>;
<span class='comment'>/* Read formatted input from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> wscanf (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format, ...)
     <span class='comment'>/* __attribute__ ((__format__ (__wscanf__, 1, 2))) */</span>;
<span class='comment'>/* Read formatted input from S.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> swscanf (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __s,
		    <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format, ...)
     __THROW <span class='comment'>/* __attribute__ ((__format__ (__wscanf__, 2, 3))) */</span>;

<span class='directive'># if defined __USE_ISOC99 &amp;&amp; !defined __USE_GNU \
     &amp;&amp; (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     &amp;&amp; (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)</span>
<span class='directive'>#  ifdef __REDIRECT</span>
<span class='comment'>/* For strict ISO C99 or POSIX compliance disallow %as, %aS and %a[
   GNU extension which conflicts with valid %a followed by letter
   s, S or [.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> __REDIRECT (fwscanf, (__FILE *__restrict __stream,
				 <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format, ...),
		       __isoc99_fwscanf)
     <span class='comment'>/* __attribute__ ((__format__ (__wscanf__, 2, 3))) */</span>;
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> __REDIRECT (wscanf, (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format, ...),
		       __isoc99_wscanf)
     <span class='comment'>/* __attribute__ ((__format__ (__wscanf__, 1, 2))) */</span>;
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> __REDIRECT_NTH (swscanf, (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __s,
				     <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
				     ...), __isoc99_swscanf)
     <span class='comment'>/* __attribute__ ((__format__ (__wscanf__, 2, 3))) */</span>;
<span class='directive'>#  else</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> __isoc99_fwscanf (__FILE *__restrict __stream,
			     <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format, ...);
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> __isoc99_wscanf (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format, ...);
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> __isoc99_swscanf (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __s,
			     <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format, ...)
     __THROW;
<span class='directive'>#   define fwscanf __isoc99_fwscanf</span>
<span class='directive'>#   define wscanf __isoc99_wscanf</span>
<span class='directive'>#   define swscanf __isoc99_swscanf</span>
<span class='directive'>#  endif</span>
<span class='directive'># endif</span>

__END_NAMESPACE_STD
<span class='directive'>#endif /* Use ISO C95, C99 and Unix98. */</span>

<span class='directive'>#ifdef __USE_ISOC99</span>
__BEGIN_NAMESPACE_C99
<span class='comment'>/* Read formatted input from S into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> vfwscanf (__FILE *__restrict __s,
		     <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
		     __gnuc_va_list __arg)
     <span class='comment'>/* __attribute__ ((__format__ (__wscanf__, 2, 0))) */</span>;
<span class='comment'>/* Read formatted input from stdin into argument list ARG.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> vwscanf (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
		    __gnuc_va_list __arg)
     <span class='comment'>/* __attribute__ ((__format__ (__wscanf__, 1, 0))) */</span>;
<span class='comment'>/* Read formatted input from S into argument list ARG.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> vswscanf (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __s,
		     <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
		     __gnuc_va_list __arg)
     __THROW <span class='comment'>/* __attribute__ ((__format__ (__wscanf__, 2, 0))) */</span>;

<span class='directive'># if !defined __USE_GNU \
     &amp;&amp; (!defined __LDBL_COMPAT || !defined __REDIRECT) \
     &amp;&amp; (defined __STRICT_ANSI__ || defined __USE_XOPEN2K)</span>
<span class='directive'>#  ifdef __REDIRECT</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> __REDIRECT (vfwscanf, (__FILE *__restrict __s,
				  <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
				  __gnuc_va_list __arg), __isoc99_vfwscanf)
     <span class='comment'>/* __attribute__ ((__format__ (__wscanf__, 2, 0))) */</span>;
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> __REDIRECT (vwscanf, (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
				 __gnuc_va_list __arg), __isoc99_vwscanf)
     <span class='comment'>/* __attribute__ ((__format__ (__wscanf__, 1, 0))) */</span>;
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> __REDIRECT_NTH (vswscanf, (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __s,
				      <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
				      __gnuc_va_list __arg), __isoc99_vswscanf)
     <span class='comment'>/* __attribute__ ((__format__ (__wscanf__, 2, 0))) */</span>;
<span class='directive'>#  else</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> __isoc99_vfwscanf (__FILE *__restrict __s,
			      <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
			      __gnuc_va_list __arg);
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> __isoc99_vwscanf (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
			     __gnuc_va_list __arg);
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> __isoc99_vswscanf (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __s,
			      <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
			      __gnuc_va_list __arg) __THROW;
<span class='directive'>#   define vfwscanf __isoc99_vfwscanf</span>
<span class='directive'>#   define vwscanf __isoc99_vwscanf</span>
<span class='directive'>#   define vswscanf __isoc99_vswscanf</span>
<span class='directive'>#  endif</span>
<span class='directive'># endif</span>

__END_NAMESPACE_C99
<span class='directive'>#endif /* Use ISO C99. */</span>


__BEGIN_NAMESPACE_STD
<span class='comment'>/* Read a character from STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> wint_t fgetwc (__FILE *__stream);
<span class='keyword extern'>extern</span> wint_t getwc (__FILE *__stream);

<span class='comment'>/* Read a character from stdin.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> wint_t getwchar (<span class='keyword void'>void</span>);


<span class='comment'>/* Write a character to STREAM.

   These functions are possible cancellation points and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> wint_t fputwc (<span class='keyword wchar_t'>wchar_t</span> __wc, __FILE *__stream);
<span class='keyword extern'>extern</span> wint_t putwc (<span class='keyword wchar_t'>wchar_t</span> __wc, __FILE *__stream);

<span class='comment'>/* Write a character to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> wint_t putwchar (<span class='keyword wchar_t'>wchar_t</span> __wc);


<span class='comment'>/* Get a newline-terminated wide character string of finite length
   from STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *fgetws (<span class='keyword wchar_t'>wchar_t</span> *__restrict __ws, <span class='keyword int'>int</span> __n,
			__FILE *__restrict __stream);

<span class='comment'>/* Write a string to STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> fputws (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __ws,
		   __FILE *__restrict __stream);


<span class='comment'>/* Push a character back onto the input buffer of STREAM.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> wint_t ungetwc (wint_t __wc, __FILE *__stream);
__END_NAMESPACE_STD


<span class='directive'>#ifdef __USE_GNU</span>
<span class='comment'>/* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> wint_t getwc_unlocked (__FILE *__stream);
<span class='keyword extern'>extern</span> wint_t getwchar_unlocked (<span class='keyword void'>void</span>);

<span class='comment'>/* This is the wide character version of a GNU extension.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> wint_t fgetwc_unlocked (__FILE *__stream);

<span class='comment'>/* Faster version when locking is not necessary.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> wint_t fputwc_unlocked (<span class='keyword wchar_t'>wchar_t</span> __wc, __FILE *__stream);

<span class='comment'>/* These are defined to be equivalent to the `char' functions defined
   in POSIX.1:1996.

   These functions are not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation they are cancellation points and
   therefore not marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> wint_t putwc_unlocked (<span class='keyword wchar_t'>wchar_t</span> __wc, __FILE *__stream);
<span class='keyword extern'>extern</span> wint_t putwchar_unlocked (<span class='keyword wchar_t'>wchar_t</span> __wc);


<span class='comment'>/* This function does the same as `fgetws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword wchar_t'>wchar_t</span> *fgetws_unlocked (<span class='keyword wchar_t'>wchar_t</span> *__restrict __ws, <span class='keyword int'>int</span> __n,
				 __FILE *__restrict __stream);

<span class='comment'>/* This function does the same as `fputws' but does not lock the stream.

   This function is not part of POSIX and therefore no official
   cancellation point.  But due to similarity with an POSIX interface
   or due to the implementation it is a cancellation point and
   therefore not marked with __THROW.  */</span>
<span class='keyword extern'>extern</span> <span class='keyword int'>int</span> fputws_unlocked (<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __ws,
			    __FILE *__restrict __stream);
<span class='directive'>#endif</span>


__BEGIN_NAMESPACE_C99
<span class='comment'>/* Format TP into S according to FORMAT.
   Write no more than MAXSIZE wide characters and return the number
   of wide characters written, or 0 if it would exceed MAXSIZE.  */</span>
<span class='keyword extern'>extern</span> size_t wcsftime (<span class='keyword wchar_t'>wchar_t</span> *__restrict __s, size_t __maxsize,
			<span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
			<span class='keyword const'>const</span> <span class='keyword struct'>struct</span> tm *__restrict __tp) __THROW;
__END_NAMESPACE_C99

<span class='directive'># ifdef __USE_GNU</span>
<span class='directive'># include &lt;xlocale.h&gt;</span>

<span class='comment'>/* Similar to `wcsftime' but takes the information from
   the provided locale and not the global locale.  */</span>
<span class='keyword extern'>extern</span> size_t wcsftime_l (<span class='keyword wchar_t'>wchar_t</span> *__restrict __s, size_t __maxsize,
			  <span class='keyword const'>const</span> <span class='keyword wchar_t'>wchar_t</span> *__restrict __format,
			  <span class='keyword const'>const</span> <span class='keyword struct'>struct</span> tm *__restrict __tp,
			  __locale_t __loc) __THROW;
<span class='directive'># endif</span>

<span class='comment'>/* The X/Open standard demands that most of the functions defined in
   the &lt;wctype.h&gt; header must also appear here.  This is probably
   because some X/Open members wrote their implementation before the
   ISO C standard was published and introduced the better solution.
   We have to provide these definitions for compliance reasons but we
   do this nonsense only if really necessary.  */</span>
<span class='directive'>#if defined __USE_UNIX98 &amp;&amp; !defined __USE_GNU</span>
<span class='directive'># define __need_iswxxx</span>
<span class='directive'># include &lt;wctype.h&gt;</span>
<span class='directive'>#endif</span>

<span class='comment'>/* Define some macros helping to catch buffer overflows.  */</span>
<span class='directive'>#if __USE_FORTIFY_LEVEL &gt; 0 &amp;&amp; defined __fortify_function</span>
<span class='directive'># include &lt;bits/wchar2.h&gt;</span>
<span class='directive'>#endif</span>

<span class='directive'>#ifdef __LDBL_COMPAT</span>
<span class='directive'># include &lt;bits/wchar-ldbl.h&gt;</span>
<span class='directive'>#endif</span>

__END_DECLS
</span>
<span class='directive'>#endif	/* _WCHAR_H defined */</span>

<span class='directive'>#endif /* wchar.h  */</span>

<span class='comment'>/* Undefine all __need_* constants in case we are included to get those
   constants but the whole file was already read.  */</span>
<span class='directive'>#undef __need_mbstate_t</span>
<span class='directive'>#undef __need_wint_t</span></span><span class='cl'></span></pre></div><script src="../../globals.js"></script><script src="../../static/jquery.min.js"></script><script src="../../static/bootstrap/js/bootstrap.min.js"></script><script src="../../static/bootstrap/js/dropdowns-enhancement.js"></script><script src="../../static/animated-modal/animatedModal.js"></script><script src="../../static/jquery.autocomplete.js"></script><script src="../../static/js.cookie.js"></script><script src="../../static/local.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-40501108-2', 'auto');ga('send', 'pageview');</script></body></html>